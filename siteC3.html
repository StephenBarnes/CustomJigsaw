<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0" />
	<title>Image Jigsaw Puzzle</title>
	<script src="https://cdn.tailwindcss.com"></script>
	<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
	<style>
		body {
			font-family: 'Inter', sans-serif;
			touch-action: none;
			overflow: hidden
		}

		.puzzle-group {
			position: absolute;
			cursor: grab;
			z-index: 10;
			filter: drop-shadow(0 2px 4px rgba(0, 0, 0, .25));
			transition: filter .1s, z-index 0s .1s
		}

		.puzzle-group.dragging {
			cursor: grabbing;
			z-index: 20;
			filter: drop-shadow(0 10px 15px rgba(0, 0, 0, .25))
		}

		.puzzle-piece {
			position: absolute;
			border: none;
			transition: transform .1s;
			background: rgba(0, 0, 0, 0.02)
		}

		.puzzle-group.dragging .puzzle-piece {
			transform: scale(1.025)
		}

		#puzzle-board {
			background: #f0f4f8;
			position: relative;
			overflow: hidden;
			border-radius: .5rem;
			box-shadow: inset 0 2px 4px rgba(0, 0, 0, .06)
		}

		#assembly-area {
			position: absolute;
			border: 2px dashed #cbd5e1;
			box-sizing: border-box;
			pointer-events: none
		}

		.control-panel {
			background: #fff;
			padding: 1.5rem;
			border-radius: .75rem;
			box-shadow: 0 10px 15px -3px rgba(0, 0, 0, .1), 0 4px 6px -2px rgba(0, 0, 0, .05)
		}

		#win-message {
			position: absolute;
			bottom: 0;
			left: 0;
			width: 100%;
			display: flex;
			justify-content: center;
			background: linear-gradient(to top, rgba(0, 0, 0, .6), transparent);
			padding: 2rem 1rem;
			box-sizing: border-box;
			opacity: 0;
			transform: translateY(100%);
			pointer-events: none;
			transition: opacity .5s, transform .5s
		}

		#win-message.show {
			opacity: 1;
			transform: translateY(0);
			pointer-events: auto
		}

		.win-message-content {
			text-align: center;
			padding: 1.5rem 3rem;
			background: #2f855a;
			border-radius: .75rem;
			box-shadow: 0 10px 25px rgba(0, 0, 0, .3)
		}

		.win-message-content h2 {
			font-size: 3rem;
			font-weight: 700;
			color: #fff
		}

		/* DEBUG HUD */
		#debug-hud {
			position: fixed;
			right: 12px;
			bottom: 12px;
			background: rgba(0, 0, 0, .88);
			color: #e2e8f0;
			border: 1px solid rgba(255, 255, 255, .15);
			border-radius: .75rem;
			padding: .75rem;
			max-width: 46vw;
			max-height: 64vh;
			overflow: auto;
			z-index: 9999;
			display: none
		}

		#debug-hud h3 {
			font-weight: 700;
			margin-bottom: .25rem
		}

		#debug-hud pre {
			font-family: ui-monospace, SFMono-Regular, Menlo, monospace;
			font-size: 12px;
			line-height: 1.3;
			white-space: pre-wrap;
			word-break: break-word
		}

		#debug-row {
			display: flex;
			gap: .75rem;
			align-items: flex-start;
			margin-top: .5rem
		}

		#debug-padded {
			background: repeating-conic-gradient(#111 0% 25%, #222 0% 50%) 50%/20px 20px;
			outline: 1px solid #475569;
			max-width: 24vw;
			height: auto
		}

		#debug-controls {
			display: flex;
			gap: .5rem;
			align-items: center;
			margin: .25rem 0 .5rem
		}

		#debug-cta button {
			font-size: 12px;
			border: 1px solid #64748b;
			padding: .25rem .5rem;
			border-radius: .25rem;
			background: #0f172a;
			color: #e2e8f0
		}
	</style>
</head>

<body class="bg-slate-100 text-slate-800 flex flex-col items-center justify-center h-screen p-4">
	<div class="w-full max-w-7xl mx-auto flex flex-col h-full">
		<header class="text-center mb-4 shrink-0">
			<h1 class="text-4xl font-bold text-slate-700">Image Jigsaw Puzzle</h1>
			<p class="text-slate-500 mt-2">Select an image, then assemble the puzzle in the center.</p>
		</header>

		<div class="control-panel mb-4 flex flex-col sm:flex-row items-center justify-center gap-4 shrink-0">
			<div class="flex items-center gap-3">
				<label for="image-loader"
					class="cursor-pointer bg-blue-500 text-white font-bold py-2 px-4 rounded-md hover:bg-blue-600 transition-colors">
					Select Image
				</label>
				<input type="file" id="image-loader" class="hidden" accept="image/png, image/jpeg, image/gif">
			</div>

			<div class="flex items-center gap-3">
				<label for="difficulty-select" class="font-medium">Difficulty:</label>
				<select id="difficulty-select" class="cursor-pointer border rounded px-2 py-1"></select>
			</div>

			<button id="scramble-btn"
				class="bg-green-500 text-white font-bold py-2 px-4 rounded-md hover:bg-green-600 transition-colors disabled:bg-gray-400 disabled:cursor-not-allowed"
				disabled>Re-Scramble</button>

			<!-- UI Debug toggle -->
			<label class="flex items-center gap-2 text-sm ml-auto select-none">
				<input id="ui-debug-toggle" type="checkbox" class="cursor-pointer">
				<span class="font-medium">Debug</span>
			</label>
		</div>

		<main id="puzzle-board-container"
			class="flex-grow w-full flex items-center justify-center relative bg-white rounded-lg shadow-md overflow-hidden">
			<div id="puzzle-board">
				<p id="board-placeholder" class="text-slate-400 absolute inset-0 flex items-center justify-center">
					The puzzle board is empty
				</p>
				<div id="win-message">
					<div class="win-message-content">
						<h2>Puzzle Solved!</h2>
					</div>
				</div>
			</div>
		</main>
	</div>

	<!-- DEBUG HUD -->
	<div id="debug-hud">
		<h3>Debug</h3>
		<div id="debug-controls">
			<label class="text-xs opacity-80"><input id="toggle-bitmap" type="checkbox"> use ImageBitmap</label>
			<label class="text-xs opacity-80"><input id="toggle-copy" type="checkbox" checked> composite=copy</label>
			<label class="text-xs opacity-80"><input id="toggle-lastditch" type="checkbox" checked> enable last-ditch</label>
		</div>
		<div id="debug-cta">
			<button id="btn-selftest">Run Canvas Self-Test</button>
		</div>
		<pre id="debug-env"></pre>
		<pre id="debug-log"></pre>
		<div id="debug-row">
			<canvas id="debug-padded"></canvas>
			<pre id="debug-metrics"></pre>
		</div>
	</div>

	<script>
		/* ================================
		App State & Feature Flags
		================================ */

		let DEBUG_ENABLED = false;            // UI toggle
		let USE_BITMAP = false;               // toggled in HUD
		let USE_COMPOSITE_COPY = true;        // toggled in HUD
		let ENABLE_LAST_DITCH = true;         // toggled in HUD

		const imageLoader = document.getElementById('image-loader');
		const difficultySelect = document.getElementById('difficulty-select');
		const scrambleBtn = document.getElementById('scramble-btn');
		const puzzleBoard = document.getElementById('puzzle-board');
		const boardPlaceholder = document.getElementById('board-placeholder');
		const winMessage = document.getElementById('win-message');
		const uiDebugToggle = document.getElementById('ui-debug-toggle');
		uiDebugToggle.checked = false;

		// Debug HUD elements (shown only when debug enabled)
		const debugHud = document.getElementById('debug-hud');
		const debugEnv = document.getElementById('debug-env');
		const debugLogEl = document.getElementById('debug-log');
		const debugPaddedCanvas = document.getElementById('debug-padded');
		const debugMetricsEl = document.getElementById('debug-metrics');
		const toggleBitmap = document.getElementById('toggle-bitmap');
		const toggleCopy = document.getElementById('toggle-copy');
		const toggleLast = document.getElementById('toggle-lastditch');
		const btnSelfTest = document.getElementById('btn-selftest');

		// Puzzle layout state
		let assemblyArea = null;
		let pieceGroups = [];
		let basePuzzleSize = 4;
		let puzzleSizeX = 4;
		let puzzleSizeY = 4;
		let pieceWidth = 0;
		let pieceHeight = 0;
		let puzzleSolved = false;
		let buildToken = 0;

		const SNAP_TOLERANCE = 25;

		// Source decoding / rendering state
		let srcFile = null;
		let frameSource = null;         // implements IFrameSource (see below)
		let sliceSourceCanvas = null;   // padded frame canvas (current frame)
		let sliceSourceW = 0;
		let sliceSourceH = 0;
		let imageAspectRatio = 1;

		// Animation loop (for future GIF support)
		let animRAF = null;
		let animRunning = false;

		/* ================================
		Building difficulty options around current image aspect.
		================================ */
		function buildDifficultyOptions() {
			if (!frameSource?.ready) {
				difficultySelect.innerHTML = '';
				return;
			}

			const aspect = imageAspectRatio; // w/h
			const options = [];

			// For k=2..12, compute gridX/gridY so pieces are ~square
			for (let k = 2; k <= 12; k++) {
				// Choose the short side = k, compute the long side ≈ k*aspect (rounded)
				let gx, gy;
				if (aspect >= 1) {
					// wide image
					gx = Math.max(3, Math.round(k * aspect));
					gy = k;
				} else {
					// tall image
					gx = k;
					gy = Math.max(3, Math.round(k / aspect));
				}
				options.push([gx, gy]);
			}

			// Deduplicate (e.g., many k may map to the same pair), and cap sizes
			const key = (p) => `${p[0]}x${p[1]}`;
			const seen = new Set();
			const deduped = [];
			for (const p of options) {
				const k = key(p);
				if (!seen.has(k) && p[0] <= 100 && p[1] <= 100) { // basic sanity caps
					seen.add(k);
					deduped.push(p);
				}
			}

			// Sort by approx number of pieces (ascending)
			deduped.sort((a, b) => (a[0] * a[1]) - (b[0] * b[1]));

			// Fill the <select>, keep the previously-selected value if possible
			const prev = `${puzzleSizeX}x${puzzleSizeY}`;
			difficultySelect.innerHTML = deduped.map(([gx, gy]) =>
				`<option value="${gx}x${gy}">${gx}×${gy}</option>`).join('');

			const first = deduped[0];
			const fallbackVal = `${first[0]}x${first[1]}`;

			const toSelect = difficultySelect.querySelector(`option[value="${prev}"]`)
				? prev : fallbackVal;

			difficultySelect.value = toSelect;

			// Apply to state
			const [gx, gy] = toSelect.split('x').map(Number);
			puzzleSizeX = gx;
			puzzleSizeY = gy;
		}

		/* ================================
		Debug helpers
		================================ */
		function ts() {
			return new Date().toISOString().slice(11, 23);
		}
		function log(...args) {
			if (!DEBUG_ENABLED) return;
			const line = `[${ts()}] ${args.map(a => (
				typeof a === 'object' ? JSON.stringify(a) : String(a)
			)).join(' ')}`;
			console.log(...args);
			if (debugLogEl) {
				debugLogEl.textContent += line + '\n';
				debugLogEl.scrollTop = debugLogEl.scrollHeight;
			}
		}
		function clearLog() {
			if (DEBUG_ENABLED && debugLogEl) debugLogEl.textContent = '';
		}
		function setDebugUI(visible) {
			DEBUG_ENABLED = visible;
			debugHud.style.display = visible ? 'block' : 'none';
			if (visible) {
				toggleBitmap.checked = USE_BITMAP;
				toggleCopy.checked = USE_COMPOSITE_COPY;
				toggleLast.checked = ENABLE_LAST_DITCH;

				debugEnv.textContent =
`UA: ${navigator.userAgent}
createImageBitmap: ${!!window.createImageBitmap}
colorSpace: ${'colorSpace' in CanvasRenderingContext2D.prototype ? 'yes' : 'no'}
getImageData: ${typeof CanvasRenderingContext2D.prototype.getImageData}
`;
			}
		}

		/* ================================
		UI Events
		================================ */
		uiDebugToggle.addEventListener('change', () => {
			setDebugUI(uiDebugToggle.checked);
		});

		imageLoader.addEventListener('change', e => {
			const file = e.target.files?.[0];
			if (!file) return;
			srcFile = file;
			loadFromFile(file);
		});

		difficultySelect.addEventListener('change', () => {
			const [gx, gy] = difficultySelect.value.split('x').map(Number);
			puzzleSizeX = gx;
			puzzleSizeY = gy;
			log('difficulty.change → rebuild');
			createPuzzle();
		});

		scrambleBtn.addEventListener('click', () => {
			if (frameSource?.ready) createPuzzle();
		});

		let resizeRAF = null;
		window.addEventListener('resize', () => {
			if (!frameSource?.ready) return;
			cancelAnimationFrame(resizeRAF);
			resizeRAF = requestAnimationFrame(() => {
				log('window.resize → rebuild');
				buildDifficultyOptions();
				createPuzzle();
			});
		});

		/* ================================
		Debug HUD event wiring
		================================ */
		toggleBitmap.addEventListener('change', () => {
			USE_BITMAP = toggleBitmap.checked;
			log('TOGGLE USE_BITMAP', USE_BITMAP);
			if (srcFile) loadFromFile(srcFile);
		});
		toggleCopy.addEventListener('change', () => {
			USE_COMPOSITE_COPY = toggleCopy.checked;
			log('TOGGLE composite=copy', USE_COMPOSITE_COPY);
			if (frameSource?.ready) createPuzzle();
		});
		toggleLast.addEventListener('change', () => {
			ENABLE_LAST_DITCH = toggleLast.checked;
			log('TOGGLE last-ditch', ENABLE_LAST_DITCH);
		});
		btnSelfTest.addEventListener('click', selfTestCanvas);

		// Extra debug button
		const btnRawDraw = document.createElement('button');
		btnRawDraw.textContent = 'Raw draw src → HUD';
			btnRawDraw.onclick = () => {
				if (!frameSource?.ready) return;
				const srcEl = frameSource.sourceElement ? frameSource.sourceElement()
					: frameSource.currentFrameCanvas();
				const w = srcEl.width || srcEl.naturalWidth || 256;
				const h = srcEl.height || srcEl.naturalHeight || 256;

				const c = debugPaddedCanvas;
				c.width = w;
				c.height = h;

				const ctx = c.getContext('2d');
				ctx.clearRect(0, 0, w, h);
				ctx.fillStyle = '#ff00ff88';
				ctx.fillRect(0, 0, w, h);

				try {
					ctx.drawImage(srcEl, 0, 0, w, h);
				} catch (e) {
					log('Raw draw ERROR', String(e));
				}
				try {
					const p = ctx.getImageData((w / 2) | 0, (h / 2) | 0, 1, 1).data;
					log('Raw draw probe (center)', Array.from(p));
				} catch (e) {
					log('Raw draw probe ERROR', String(e));
				}
			};

			document.getElementById('debug-cta').appendChild(btnRawDraw);

		/* ================================
		IFrameSource (prepping for GIFs)
		--------------------------------
		StaticImageSource: wraps a single decoded image or ImageBitmap.
		Future: GifFrameSource: decodes frames & exposes a synced canvas.
		================================ */

		function fileToDataURL(file) {
			return new Promise((res, rej) => {
				const r = new FileReader();
				r.onerror = () => rej(r.error);
				r.onload = () => res(r.result);
				r.readAsDataURL(file);
			});
		}
		function loadHTMLImage(src) {
			return new Promise((res, rej) => {
				const img = new Image();
				img.decoding = 'async';
				img.onload = async () => {
					try { if (img.decode) await img.decode(); } catch { }
					res(img);
				};
				img.onerror = rej;
				img.src = src;
			});
		}

		class StaticImageSource {
			constructor(width, height, source) {
				this.ready = true;
				this.animated = false;
				this.width = width;
				this.height = height;
				this._element = source;
				this._canvas = document.createElement('canvas');
				this._canvas.width = width;
				this._canvas.height = height;
				const ctx = this._canvas.getContext('2d');
				ctx.drawImage(source, 0, 0, width, height);
			}
			currentFrameCanvas() {
				return this._canvas;
			}
			sourceElement() {
				return this._element;
			}
			start() {}
			stop() {}
		}

		// Placeholder for the next project (animated GIFs)
		// class GifFrameSource { ... }  // to be implemented

		/* ================================
		Load & Decode (creates a FrameSource)
		================================ */
		async function loadFromFile(file) {
			clearLog();
			stopAnimationLoop();

			puzzleSolved = false;
			scrambleBtn.disabled = true;
			frameSource = null;

			log('onSelectFile', { name: file.name, size: file.size, type: file.type });

			if (file.type === 'image/gif') {
				// Future: swap to GifFrameSource that decodes frames and keeps a sync clock.
				alert('GIF selected. Animated pieces are planned for the next step. For now, please select a PNG or JPG.');
				return;
			}

			try {
				let srcBitmap = null;
				let srcImage = null;

				if (USE_BITMAP && window.createImageBitmap) {
					srcBitmap = await createImageBitmap(file, {
						imageOrientation: 'from-image',
						premultiplyAlpha: 'premultiply',
						colorSpaceConversion: 'default'
					});
					imageAspectRatio = srcBitmap.width / srcBitmap.height;
					log('createImageBitmap(file) OK', { w: srcBitmap.width, h: srcBitmap.height });
					frameSource = new StaticImageSource(srcBitmap.width, srcBitmap.height, srcBitmap);
				} else {
					const dataURL = await fileToDataURL(file);
					srcImage = await loadHTMLImage(dataURL);
					imageAspectRatio = srcImage.naturalWidth / srcImage.naturalHeight;
					log('HTMLImageElement loaded', { w: srcImage.naturalWidth, h: srcImage.naturalHeight });
					frameSource = new StaticImageSource(srcImage.naturalWidth, srcImage.naturalHeight, srcImage);
				}
			} catch (err) {
				log('DECODE ERROR', String(err));
				alert('Failed to decode image.');
				return;
			}

			buildDifficultyOptions();
			scrambleBtn.disabled = false;
			createPuzzle();

			// If we later support GIFs:
			// if (frameSource.animated) startAnimationLoop();
		}

		/* ================================
		Padded Source Builder
		- Keeps previous copy/last-ditch debugging knobs.
		================================ */
		function buildPaddedSource(gridX, gridY, token) {
			const srcEl = frameSource.sourceElement ? frameSource.sourceElement()
													: frameSource.currentFrameCanvas();
			const srcW = srcEl.width || srcEl.naturalWidth;
			const srcH = srcEl.height || srcEl.naturalHeight;

			const paddedW = Math.ceil(srcW / gridX) * gridX;
			const paddedH = Math.ceil(srcH / gridY) * gridY;

			const canvas = document.createElement('canvas');
			canvas.width = paddedW;
			canvas.height = paddedH;

			const ctx = canvas.getContext('2d');

			// Canary background
			ctx.fillStyle = '#ff00ff88';
			ctx.fillRect(0, 0, paddedW, paddedH);

			const offsetX = Math.floor((paddedW - srcW) / 2);
			const offsetY = Math.floor((paddedH - srcH) / 2);

			let drew = attemptDrawTo(ctx, srcEl, offsetX, offsetY, srcW, srcH, 'source-over');

			if (!drew && USE_COMPOSITE_COPY) {
				drew = attemptDrawTo(ctx, srcEl, offsetX, offsetY, srcW, srcH, 'copy');
			}

			// Optional "last ditch" branch retained for debug parity (no-op here)
			if (!drew && ENABLE_LAST_DITCH) {
				// In a future GIF pipeline we might recompose the frame differently.
				drew = attemptDrawTo(ctx, srcEl, offsetX, offsetY, srcW, srcH, 'source-over');
			}

			// Crosshair (debug)
			if (DEBUG_ENABLED) {
				ctx.save();
				ctx.strokeStyle = '#ff0000cc';
				ctx.beginPath();
				ctx.moveTo(offsetX, offsetY - 6);
				ctx.lineTo(offsetX, offsetY + 6);
				ctx.moveTo(offsetX - 6, offsetY);
				ctx.lineTo(offsetX + 6, offsetY);
				ctx.stroke();
				ctx.restore();
			}

			let aTL = 0, aMid = 0;
			try {
				const tl = ctx.getImageData(Math.max(0, offsetX), Math.max(0, offsetY), 1, 1).data;
				const mid = ctx.getImageData(paddedW / 2, paddedH / 2, 1, 1).data;
				aTL = tl[3];
				aMid = mid[3];
				log('padded-samples', { TL: Array.from(tl), MID: Array.from(mid), sum: aTL + aMid });
			} catch (err) {
				log('getImageData ERROR', String(err));
			}

			if (DEBUG_ENABLED) {
				const dbg = debugPaddedCanvas;
				dbg.width = paddedW;
				dbg.height = paddedH;
				const dctx = dbg.getContext('2d');
				dctx.clearRect(0, 0, paddedW, paddedH);
				dctx.drawImage(canvas, 0, 0);
				debugMetricsEl.textContent =
`Token: ${token}
Src: ${srcW}×${srcH}
Padded: ${paddedW}×${paddedH}
Grid: ${gridX}×${gridY}
Piece: ${(paddedW / gridX) | 0}×${(paddedH / gridY) | 0}
Samples: TL a=${aTL} MID a=${aMid} sum=${aTL + aMid}
Path: ${frameSource.animated ? 'Animated' : 'Static'}
DrawOK: ${drew ? 'yes' : 'NO (used fallback)'}
`;
			}

			return { canvas, width: paddedW, height: paddedH };
		}

		function attemptDrawTo(ctx, srcDrawable, x, y, w, h, compOp = 'source-over') {
			ctx.save();
			ctx.globalCompositeOperation = compOp;
			ctx.clearRect(x, y, w, h);
			let drew = false;

			try {
				ctx.drawImage(srcDrawable, x, y, w, h);
			} catch (err) {
				log('attemptDrawTo ERROR', { compOp, err: String(err) });
			}

			try {
				const mid = ctx.getImageData(x + (w / 2), y + (h / 2), 1, 1).data;
				drew = mid[3] > 0;
			} catch (err) {
				log('probe ERROR', String(err));
			}

			ctx.globalCompositeOperation = 'destination-over';
			ctx.fillStyle = '#00000022';
			ctx.fillRect(x, y, w, h);
			ctx.restore();

			log('attemptDrawTo', { compOp, drew });
			return drew;
		}

		/* ================================
		Build / Render
		================================ */
		function createPuzzle() {
			const myToken = ++buildToken;
			log('createPuzzle start', { token: myToken });

			stopAnimationLoop();
			pieceGroups = [];
			puzzleSolved = false;

			const container = puzzleBoard.parentElement;
			const containerWidth = container.clientWidth;
			const containerHeight = container.clientHeight;

			log('container size', { containerWidth, containerHeight });

			if (containerWidth < 10 || containerHeight < 10) {
				log('container too small, reflow defer');
				requestAnimationFrame(() => { if (myToken === buildToken) createPuzzle(); });
				return;
			}

			puzzleBoard.innerHTML = '';

			assemblyArea = document.createElement('div');
			assemblyArea.id = 'assembly-area';
			puzzleBoard.appendChild(assemblyArea);
			puzzleBoard.appendChild(boardPlaceholder);
			puzzleBoard.appendChild(winMessage);

			winMessage.classList.remove('show');
			boardPlaceholder.style.display = 'none';

			const padded = buildPaddedSource(puzzleSizeX, puzzleSizeY, myToken);
			if (myToken !== buildToken) {
				log('stale build after padded; abort', { token: myToken });
				return;
			}

			sliceSourceCanvas = padded.canvas;
			sliceSourceW = padded.width;
			sliceSourceH = padded.height;

			const paddedAspect = sliceSourceW / sliceSourceH;

			// Compute assembly size to be a multiple of the grid (no leftover pixels)
			let assemblyWidth = Math.floor(containerWidth * 0.5);
			let assemblyHeight = Math.round(assemblyWidth / paddedAspect);

			if (assemblyHeight > Math.floor(containerHeight * 0.8)) {
				assemblyHeight = Math.floor(containerHeight * 0.8);
				assemblyWidth = Math.round(assemblyHeight * paddedAspect);
			}

			const boardWidth = containerWidth;
			const boardHeight = containerHeight;

			puzzleBoard.style.width = `${boardWidth}px`;
			puzzleBoard.style.height = `${boardHeight}px`;

			pieceWidth  = Math.max(1, Math.floor(assemblyWidth  / puzzleSizeX));
			pieceHeight = Math.max(1, Math.floor(assemblyHeight / puzzleSizeY));
			assemblyWidth  = pieceWidth  * puzzleSizeX;
			assemblyHeight = pieceHeight * puzzleSizeY;

			const assemblyX = (boardWidth - assemblyWidth) / 2;
			const assemblyY = (boardHeight - assemblyHeight) / 2;

			assemblyArea.style.width = `${assemblyWidth}px`;
			assemblyArea.style.height = `${assemblyHeight}px`;
			assemblyArea.style.left = `${assemblyX}px`;
			assemblyArea.style.top = `${assemblyY}px`;

			log('layout', { assemblyWidth, assemblyHeight, pieceWidth, pieceHeight });

			let sw = sliceSourceW / puzzleSizeX;
			let sh = sliceSourceH / puzzleSizeY;
			log('source-slice', { sw, sh });

			for (let y = 0; y < puzzleSizeY; y++) {
				for (let x = 0; x < puzzleSizeX; x++) {
					if (myToken !== buildToken) {
						log('stale build mid-loop; abort', { token: myToken });
						return;
					}
					const piece = createPieceCanvas(x, y, sw, sh);
					const group = createPieceGroup(piece);
					placeGroupRandomly(
						group,
						boardWidth,
						boardHeight,
						{ x: assemblyX, y: assemblyY, width: assemblyWidth, height: assemblyHeight }
					);
					puzzleBoard.appendChild(group.element);
					pieceGroups.push(group);
				}
			}

			log('createPuzzle done', { token: myToken, pieces: pieceGroups.length });

			// If animated in future (GIF), start render loop to refresh pieces.
			// if (frameSource.animated) startAnimationLoop();
		}

		function createPieceCanvas(gridX, gridY, sw, sh) {
			const piece = document.createElement('canvas');
			piece.className = 'puzzle-piece';

			piece.width = Math.max(1, pieceWidth);
			piece.height = Math.max(1, pieceHeight);

			piece.style.width = `${pieceWidth}px`;
			piece.style.height = `${pieceHeight}px`;
			piece.style.left = '0px';
			piece.style.top = '0px';

			piece.dataset.correctX = gridX;
			piece.dataset.correctY = gridY;

			renderPieceFromCurrentFrame(piece, gridX, gridY, sw, sh);

			return piece;
		}

		function renderPieceFromCurrentFrame(piece, gridX, gridY, sw, sh) {
			const ctx = piece.getContext('2d');

			ctx.clearRect(0, 0, piece.width, piece.height);
			ctx.fillStyle = '#00000011';
			ctx.fillRect(0, 0, piece.width, piece.height);

			const sx = gridX * sw;
			const sy = gridY * sh;

			try {
				ctx.drawImage(
					sliceSourceCanvas,
					gridX * sw, gridY * sh, sw, sh,
					0, 0, piece.width, piece.height
				);
			} catch (err) {
				log('ERROR drawImage piece', { gridX, gridY, err: String(err) });
			}

			if (DEBUG_ENABLED) {
				try {
					const w = Math.min(8, piece.width), h = Math.min(8, piece.height);
					const data = ctx.getImageData(0, 0, w, h).data;
					let aSum = 0; for (let i = 3; i < data.length; i += 4) aSum += data[i];
					log('piece-sample', { gridX, gridY, aSum });
				} catch (err) {
					log('piece-sample ERROR', String(err));
				}
			}
		}

		/* ================================
		Animation loop (future GIF)
		- For static sources this is off.
		- For GIFs: update sliceSourceCanvas from frameSource
		  and redraw each piece from the new frame.
		================================ */
		function startAnimationLoop() {
			if (animRunning) return;
			animRunning = true;

			const step = () => {
				if (!animRunning || !frameSource?.animated) return;
				// 1) refresh current frame canvas from source
				// 2) rebuild padded slice from current frame (cheap: same size)
				const padded = buildPaddedSource(puzzleSizeX, puzzleSizeY, buildToken);
				sliceSourceCanvas = padded.canvas;
				sliceSourceW = padded.width;
				sliceSourceH = padded.height;

				const sw = sliceSourceW / puzzleSizeX;
				const sh = sliceSourceH / puzzleSizeY;

				// 3) redraw all pieces
				for (const group of pieceGroups) {
					for (const piece of group.pieces) {
						const gx = parseInt(piece.dataset.correctX);
						const gy = parseInt(piece.dataset.correctY);
						renderPieceFromCurrentFrame(piece, gx, gy, sw, sh);
					}
				}
				animRAF = requestAnimationFrame(step);
			};
			animRAF = requestAnimationFrame(step);
		}
		function stopAnimationLoop() {
			animRunning = false;
			if (animRAF) cancelAnimationFrame(animRAF);
			animRAF = null;
		}

		/* ================================
		Dragging / Merge (unchanged behavior)
		================================ */
		function createPieceGroup(initialPiece) {
			const groupElement = document.createElement('div');
			groupElement.className = 'puzzle-group';
			groupElement.appendChild(initialPiece);

			const group = {
				element: groupElement,
				pieces: [initialPiece],
				minX: parseInt(initialPiece.dataset.correctX),
				minY: parseInt(initialPiece.dataset.correctY),
				widthInPieces: 1,
				heightInPieces: 1,
			};

			addDragListeners(group);
			return group;
		}

		function placeGroupRandomly(group, boardW, boardH, assemblyRect) {
			const pw = pieceWidth, ph = pieceHeight;
			let x, y;

			const placementArea = Math.floor(Math.random() * 4);
			const safeW = Math.max(0, boardW - pw);
			const safeH = Math.max(0, boardH - ph);

			switch (placementArea) {
				case 0:
					x = Math.random() * safeW;
					y = Math.max(0, Math.random() * Math.max(0, assemblyRect.y - ph));
					break;
				case 1:
					x = Math.random() * safeW;
					y = (assemblyRect.y + assemblyRect.height) +
						Math.random() * Math.max(0, boardH - (assemblyRect.y + assemblyRect.height) - ph);
					break;
				case 2:
					x = Math.max(0, Math.random() * Math.max(0, assemblyRect.x - pw));
					y = Math.random() * safeH;
					break;
				default:
					x = (assemblyRect.x + assemblyRect.width) +
						Math.random() * Math.max(0, boardW - (assemblyRect.x + assemblyRect.width) - pw);
					y = Math.random() * safeH;
					break;
			}

			group.element.style.left = `${Math.max(0, x || 0)}px`;
			group.element.style.top = `${Math.max(0, y || 0)}px`;
		}

		function addDragListeners(group) {
			let offsetX, offsetY;
			const groupElement = group.element;

			function onDragStart(e) {
				if (puzzleSolved) return;
				e.preventDefault();

				groupElement.classList.add('dragging');
				puzzleBoard.appendChild(groupElement);

				const t = e.touches?.[0] || e;
				const clientX = t.clientX;
				const clientY = t.clientY;

				const rect = groupElement.getBoundingClientRect();
				offsetX = clientX - rect.left;
				offsetY = clientY - rect.top;

				document.addEventListener('mousemove', onDragMove);
				document.addEventListener('mouseup', onDragEnd);
				document.addEventListener('touchmove', onDragMove, { passive: false });
				document.addEventListener('touchend', onDragEnd);
			}

			function onDragMove(e) {
				e.preventDefault();

				const t = e.touches?.[0] || e;
				const clientX = t.clientX;
				const clientY = t.clientY;

				const boardRect = puzzleBoard.getBoundingClientRect();

				let newX = clientX - boardRect.left - offsetX;
				let newY = clientY - boardRect.top - offsetY;

				const groupWidth = group.widthInPieces * pieceWidth;
				const groupHeight = group.heightInPieces * pieceHeight;

				const maxX = puzzleBoard.clientWidth - groupWidth;
				const maxY = puzzleBoard.clientHeight - groupHeight;

				newX = Math.max(0, Math.min(newX, maxX));
				newY = Math.max(0, Math.min(newY, maxY));

				groupElement.style.left = `${newX | 0}px`;
				groupElement.style.top = `${newY | 0}px`;
			}

			function onDragEnd() {
				groupElement.classList.remove('dragging');

				document.removeEventListener('mousemove', onDragMove);
				document.removeEventListener('mouseup', onDragEnd);
				document.removeEventListener('touchmove', onDragMove);
				document.removeEventListener('touchend', onDragEnd);

				checkForMultiSnap(group);
			}

			groupElement.addEventListener('mousedown', onDragStart);
			groupElement.addEventListener('touchstart', onDragStart, { passive: true });
		}

		function checkForMultiSnap(draggedGroup) {
			let groupToCheck = draggedGroup;
			let madeAMerge = true;

			while (madeAMerge) {
				madeAMerge = false;

				for (let i = pieceGroups.length - 1; i >= 0; i--) {
					const stationaryGroup = pieceGroups[i];
					if (stationaryGroup === groupToCheck) continue;

					const snapResult = findAndPerformSnap(groupToCheck, stationaryGroup);
					if (snapResult) {
						groupToCheck = stationaryGroup;
						madeAMerge = true;
						break;
					}
				}
			}
		}

		function findAndPerformSnap(draggedGroup, stationaryGroup) {
			for (const draggedPiece of draggedGroup.pieces) {
				for (const stationaryPiece of stationaryGroup.pieces) {
					const dir = checkAdjacency(draggedPiece, stationaryPiece);
					if (dir) {
						alignAndMerge(draggedGroup, stationaryGroup, draggedPiece, stationaryPiece, dir);
						return true;
					}
				}
			}
			return false;
		}

		function checkAdjacency(dp, sp) {
			const dpX = parseInt(dp.dataset.correctX);
			const dpY = parseInt(dp.dataset.correctY);
			const spX = parseInt(sp.dataset.correctX);
			const spY = parseInt(sp.dataset.correctY);

			const dr = dp.getBoundingClientRect();
			const sr = sp.getBoundingClientRect();

			if (dpX === spX + 1 && dpY === spY &&
				Math.abs(dr.left - sr.right) < SNAP_TOLERANCE &&
				Math.abs(dr.top - sr.top) < SNAP_TOLERANCE) return 'right';

			if (dpX === spX - 1 && dpY === spY &&
				Math.abs(dr.right - sr.left) < SNAP_TOLERANCE &&
				Math.abs(dr.top - sr.top) < SNAP_TOLERANCE) return 'left';

			if (dpY === spY + 1 && dpX === spX &&
				Math.abs(dr.top - sr.bottom) < SNAP_TOLERANCE &&
				Math.abs(dr.left - sr.left) < SNAP_TOLERANCE) return 'down';

			if (dpY === spY - 1 && dpX === spX &&
				Math.abs(dr.bottom - sr.top) < SNAP_TOLERANCE &&
				Math.abs(dr.left - sr.left) < SNAP_TOLERANCE) return 'up';

			return null;
		}

		function alignAndMerge(dg, sg, dp, sp, direction) {
			const sgPos = { left: sg.element.offsetLeft, top: sg.element.offsetTop };
			const spOff = { left: parseFloat(sp.style.left), top: parseFloat(sp.style.top) };
			const dpOff = { left: parseFloat(dp.style.left), top: parseFloat(dp.style.top) };

			let targetLeft, targetTop;

			switch (direction) {
				case 'right':
					targetLeft = sgPos.left + spOff.left + pieceWidth - dpOff.left;
					targetTop = sgPos.top + spOff.top - dpOff.top;
					break;
				case 'left':
					targetLeft = sgPos.left + spOff.left - pieceWidth - dpOff.left;
					targetTop = sgPos.top + spOff.top - dpOff.top;
					break;
				case 'down':
					targetLeft = sgPos.left + spOff.left - dpOff.left;
					targetTop = sgPos.top + spOff.top + pieceHeight - dpOff.top;
					break;
				case 'up':
					targetLeft = sgPos.left + spOff.left - dpOff.left;
					targetTop = sgPos.top + spOff.top - pieceHeight - dpOff.top;
					break;
			}

			dg.element.style.left = `${targetLeft | 0}px`;
			dg.element.style.top = `${targetTop | 0}px`;

			mergeGroups(dg, sg);
		}

		function mergeGroups(dg, sg) {
			const dEl = dg.element;
			const sEl = sg.element;

			const offsetX = dEl.offsetLeft - sEl.offsetLeft;
			const offsetY = dEl.offsetTop - sEl.offsetTop;

			while (dEl.firstChild) {
				const piece = dEl.firstChild;
				piece.style.left = `${(parseFloat(piece.style.left) + offsetX) | 0}px`;
				piece.style.top = `${(parseFloat(piece.style.top) + offsetY) | 0}px`;
				sEl.appendChild(piece);
				sg.pieces.push(piece);
			}

			let minX = Infinity, minY = Infinity;
			for (const p of sg.pieces) {
				const l = parseFloat(p.style.left);
				const t = parseFloat(p.style.top);
				if (l < minX) minX = l;
				if (t < minY) minY = t;
			}

			if (minX || minY) {
				sEl.style.left = `${(sEl.offsetLeft + minX) | 0}px`;
				sEl.style.top = `${(sEl.offsetTop + minY) | 0}px`;

				for (const p of sg.pieces) {
					p.style.left = `${(parseFloat(p.style.left) - minX) | 0}px`;
					p.style.top = `${(parseFloat(p.style.top) - minY) | 0}px`;
				}
			}

			puzzleBoard.removeChild(dEl);
			pieceGroups = pieceGroups.filter(g => g !== dg);

			sg.minX = Math.min(sg.minX, dg.minX);
			sg.minY = Math.min(sg.minY, dg.minY);

			let maxX = sg.minX, maxY = sg.minY;
			for (const p of sg.pieces) {
				const px = parseInt(p.dataset.correctX);
				const py = parseInt(p.dataset.correctY);
				if (px > maxX) maxX = px;
				if (py > maxY) maxY = py;
			}

			sg.widthInPieces = maxX - sg.minX + 1;
			sg.heightInPieces = maxY - sg.minY + 1;

			checkWinCondition();
		}

		function checkWinCondition() {
			if (pieceGroups.length === 1 &&
				pieceGroups[0].pieces.length === puzzleSizeX * puzzleSizeY) {

				const finalGroup = pieceGroups[0];

				const finalX = assemblyArea.offsetLeft - (finalGroup.minX * pieceWidth);
				const finalY = assemblyArea.offsetTop - (finalGroup.minY * pieceHeight);

				finalGroup.element.style.transition = 'left .5s, top .5s, filter .5s';
				finalGroup.element.style.left = `${finalX}px`;
				finalGroup.element.style.top = `${finalY}px`;
				finalGroup.element.style.cursor = 'default';
				finalGroup.element.style.zIndex = '5';
				finalGroup.element.style.filter = 'none';

				puzzleSolved = true;
				winMessage.classList.add('show');

				stopAnimationLoop();
			}
		}

		/* ================================
		Debug: Canvas self-test
		================================ */
		function selfTestCanvas() {
			const w = 256, h = 256;
			const c = debugPaddedCanvas;
			c.width = w;
			c.height = h;

			const ctx = c.getContext('2d');

			const g = ctx.createLinearGradient(0, 0, w, h);
			g.addColorStop(0, '#0ea5e9');
			g.addColorStop(1, '#22c55e');

			ctx.fillStyle = g;
			ctx.fillRect(0, 0, w, h);

			ctx.fillStyle = '#ffffff';
			ctx.fillRect(124, 124, 8, 8);

			const dot = ctx.getImageData(128, 128, 1, 1).data;
			log('SELF-TEST pixel (should be white, a>0):', Array.from(dot));
		}
	</script>
</body>
</html>