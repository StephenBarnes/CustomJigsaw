<!DOCTYPE html>
<html lang="en" class="h-full">

<head>
	<meta charset="UTF-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0" />
	<title>Custom Jigsaw Puzzle</title>
	<script src="https://cdn.tailwindcss.com"></script>
	<script src="https://unpkg.com/gifler@0.1.0/gifler.min.js"></script>
	<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
	<style>
		:root {
			color-scheme: light dark;
		}

		html,
		body {
			height: 100%;
		}

		body {
			font-family: 'Inter', sans-serif;
			touch-action: none;
			overflow: hidden;
		}

		/* Pieces */
		.puzzle-group {
			position: absolute;
			cursor: grab;
			z-index: 10;
			filter: drop-shadow(0 2px 4px rgba(0, 0, 0, .25));
			transition: filter .1s, z-index 0s .1s;
		}

		.puzzle-group.dragging {
			cursor: grabbing;
			z-index: 20;
			filter: drop-shadow(0 10px 15px rgba(0, 0, 0, .25));
		}

		.puzzle-piece {
			position: absolute;
			border: none;
			transition: transform .1s;
			background: rgba(0, 0, 0, 0.02);
		}

		.puzzle-group.dragging .puzzle-piece {
			transform: scale(1.025);
		}

		/* Board */
		#puzzle-board {
			background: #f0f4f8;
			position: relative;
			overflow: hidden;
			border-radius: .5rem;
			box-shadow: inset 0 2px 4px rgba(0, 0, 0, .06);
		}

		html.dark #puzzle-board {
			background: #0b1220;
			box-shadow: inset 0 2px 4px rgba(255, 255, 255, .04);
		}

		#assembly-area {
			position: absolute;
			border: 2px dashed #cbd5e1;
			box-sizing: border-box;
			pointer-events: none;
		}

		html.dark #assembly-area {
			border-color: #334155;
		}

		.control-panel {
			background: #fff;
			padding: 1rem;
			border-radius: .75rem;
			box-shadow: 0 10px 15px -3px rgba(0, 0, 0, .1), 0 4px 6px -2px rgba(0, 0, 0, .05);
		}

		html.dark .control-panel {
			background: #0f172a;
			box-shadow: 0 10px 20px -10px rgba(2, 6, 23, .8), 0 2px 6px -2px rgba(2, 6, 23, .6);
		}

		#win-message {
			position: absolute;
			bottom: 0;
			left: 0;
			width: 100%;
			display: flex;
			justify-content: center;
			background: linear-gradient(to top, rgba(0, 0, 0, .6), transparent);
			padding: 2rem 1rem;
			box-sizing: border-box;
			opacity: 0;
			transform: translateY(100%);
			pointer-events: none;
			transition: opacity .5s, transform .5s;
		}

		#win-message.show {
			opacity: 1;
			transform: translateY(0);
			pointer-events: auto;
		}

		.win-message-content {
			text-align: center;
			padding: 1.25rem 2rem;
			background: #16a34a;
			border-radius: .75rem;
			box-shadow: 0 10px 25px rgba(0, 0, 0, .3);
		}

		.win-message-content h2 {
			font-size: 2rem;
			font-weight: 700;
			color: #fff;
		}

		/* DEBUG HUD */
		#debug-hud {
			position: fixed;
			right: 12px;
			bottom: 12px;
			background: rgba(0, 0, 0, .88);
			color: #e2e8f0;
			border: 1px solid rgba(255, 255, 255, .15);
			border-radius: .75rem;
			padding: .75rem;
			max-width: 46vw;
			max-height: 64vh;
			overflow: auto;
			z-index: 9999;
			display: none;
		}

		#debug-hud h3 {
			font-weight: 700;
			margin-bottom: .25rem;
		}

		#debug-hud pre {
			font-family: ui-monospace, SFMono-Regular, Menlo, monospace;
			font-size: 12px;
			line-height: 1.3;
			white-space: pre-wrap;
			word-break: break-word;
		}

		#debug-row {
			display: flex;
			gap: .75rem;
			align-items: flex-start;
			margin-top: .5rem;
		}

		#debug-padded {
			background: repeating-conic-gradient(#111 0% 25%, #222 0% 50%) 50%/20px 20px;
			outline: 1px solid #475569;
			max-width: 24vw;
			height: auto;
		}

		#debug-controls {
			display: flex;
			gap: .5rem;
			align-items: center;
			margin: .25rem 0 .5rem;
		}

		#debug-cta button {
			font-size: 12px;
			border: 1px solid #64748b;
			padding: .25rem .5rem;
			border-radius: .25rem;
			background: #0f172a;
			color: #e2e8f0;
		}
	</style>
</head>

<body class="bg-slate-100 dark:bg-slate-950 text-slate-800 dark:text-slate-200 flex flex-col h-full">
	<div class="w-full mx-auto flex flex-col h-full px-4 py-3 gap-3">
		<!-- Header: condensed, helper text on the right -->
		<header class="flex items-center gap-3 justify-between shrink-0">
			<h1 class="text-2xl sm:text-3xl font-bold text-slate-700 dark:text-slate-100">Image Jigsaw Puzzle</h1>
			<div class="flex items-center gap-3 text-sm text-slate-500 dark:text-slate-400">
				<span class="hidden sm:inline">Select an image, then assemble the puzzle.</span>
				<!-- Dark mode toggle -->
				<label class="flex items-center gap-2 select-none cursor-pointer">
					<input id="dark-toggle" type="checkbox" class="toggle cursor-pointer">
					<span>Dark mode</span>
				</label>
			</div>
		</header>

		<!-- Controls -->
		<div class="control-panel flex flex-col lg:flex-row items-center gap-3 shrink-0">
			<div class="flex items-center gap-3">
				<label for="image-loader"
					class="cursor-pointer bg-blue-600 text-white font-semibold py-2 px-4 rounded-md hover:bg-blue-700 transition-colors">Select
					Image</label>
				<input type="file" id="image-loader" class="hidden" accept="image/png, image/jpeg, image/gif">
			</div>

			<div class="flex items-center gap-2">
				<label for="difficulty-select" class="font-medium">Difficulty:</label>
				<select id="difficulty-select"
					class="cursor-pointer border dark:border-slate-700 bg-white dark:bg-slate-900 rounded px-2 py-1"></select>
			</div>

			<button id="scramble-btn"
				class="bg-green-600 text-white font-semibold py-2 px-4 rounded-md hover:bg-green-700 transition-colors disabled:bg-gray-400 disabled:cursor-not-allowed"
				disabled>Scramble</button>

			<!-- GIF performance controls -->
			<div class="flex items-center gap-2 ml-0 lg:ml-auto">
				<label class="flex items-center gap-2 text-sm select-none"><input id="pause-on-drag" type="checkbox"
						class="cursor-pointer"><span>Pause GIF on drag</span></label>
				<div class="flex items-center gap-2 text-sm select-none">
					<label for="anim-speed">Anim speed</label>
					<input id="anim-speed" type="range" min="0" max="1" step="0.01" value="1" class="w-36">
					<span id="anim-speed-label" class="tabular-nums w-10 text-right">1.00×</span>
				</div>
			</div>

			<!-- UI Debug toggle -->
			<label class="flex items-center gap-2 text-sm select-none">
				<input id="ui-debug-toggle" type="checkbox" class="cursor-pointer"><span
					class="font-medium">Debug</span>
			</label>
		</div>

		<!-- Board container: take all remaining space -->
		<main id="puzzle-board-container"
			class="flex-grow w-full flex items-stretch justify-stretch relative bg-white/70 dark:bg-slate-900 rounded-lg shadow-md overflow-hidden">
			<div id="puzzle-board" class="w-full h-full">
				<p id="board-placeholder"
					class="text-slate-400 dark:text-slate-500 absolute inset-0 flex items-center justify-center">The
					puzzle board is empty</p>
				<div id="win-message">
					<div class="win-message-content">
						<h2>Puzzle Solved!</h2>
					</div>
				</div>
			</div>
		</main>
	</div>

	<!-- DEBUG HUD -->
	<div id="debug-hud">
		<h3>Debug</h3>
		<div id="debug-controls">
			<label class="text-xs opacity-80"><input id="toggle-bitmap" type="checkbox"> use ImageBitmap</label>
			<label class="text-xs opacity-80"><input id="toggle-copy" type="checkbox" checked> composite=copy</label>
		</div>
		<div id="debug-cta">
			<button id="btn-selftest">Run Canvas Self-Test</button>
		</div>
		<pre id="debug-env"></pre>
		<pre id="debug-log"></pre>
		<div id="debug-row"><canvas id="debug-padded"></canvas>
			<pre id="debug-metrics"></pre>
		</div>
	</div>

	<script>
		/* ================================
		   App State & Feature Flags
		================================= */
		let DEBUG_ENABLED = false;      // UI toggle
		let USE_BITMAP = false;         // toggled in HUD
		let USE_COMPOSITE_COPY = true;  // toggled in HUD

		const imageLoader = document.getElementById('image-loader');
		const difficultySelect = document.getElementById('difficulty-select');
		const scrambleBtn = document.getElementById('scramble-btn');
		const puzzleBoard = document.getElementById('puzzle-board');
		const boardPlaceholder = document.getElementById('board-placeholder');
		const winMessage = document.getElementById('win-message');
		const uiDebugToggle = document.getElementById('ui-debug-toggle');
		const darkToggle = document.getElementById('dark-toggle');

		// New controls
		const pauseOnDragCheckbox = document.getElementById('pause-on-drag');
		const animSpeedSlider = document.getElementById('anim-speed');
		const animSpeedLabel = document.getElementById('anim-speed-label');

		uiDebugToggle.checked = false;

		// Debug HUD elements
		const debugHud = document.getElementById('debug-hud');
		const debugEnv = document.getElementById('debug-env');
		const debugLogEl = document.getElementById('debug-log');
		const debugPaddedCanvas = document.getElementById('debug-padded');
		const debugMetricsEl = document.getElementById('debug-metrics');
		const toggleBitmap = document.getElementById('toggle-bitmap');
		const toggleCopy = document.getElementById('toggle-copy');
		const btnSelfTest = document.getElementById('btn-selftest');

		// Puzzle layout state
		let assemblyArea = null;
		let pieceGroups = [];
		let puzzleSizeX = 4;
		let puzzleSizeY = 4;
		let pieceWidth = 0;
		let pieceHeight = 0;
		let puzzleSolved = false;
		let buildToken = 0;

		const SNAP_TOLERANCE = 25;

		// Source decoding / rendering state
		let srcFile = null;
		let frameSource = null;       // implements IFrameSource
		let sliceSourceCanvas = null; // padded frame canvas (current frame)
		let sliceSourceW = 0;
		let sliceSourceH = 0;
		let imageAspectRatio = 1;
		let paddedReuseCanvas = null; // reused for slicing

		// Animation loop control (independent of GIF timing)
		let animRAF = null;
		let repaintRunning = false;   // our repaint loop state
		let animatorWasRunning = false; // remember pre-drag state
		let currentSpeed = 1;         // 0..1

		/* ================================
		   Difficulty options based on aspect
		================================= */
		function buildDifficultyOptions() {
			if (!frameSource?.ready) { difficultySelect.innerHTML = ''; return; }
			const aspect = imageAspectRatio;
			const options = [];
			for (let k = 2; k <= 12; k++) {
				let gx, gy;
				if (aspect >= 1) { gx = Math.max(3, Math.round(k * aspect)); gy = k; }
				else { gx = k; gy = Math.max(3, Math.round(k / aspect)); }
				options.push([gx, gy]);
			}
			const seen = new Set(), deduped = [];
			for (const p of options) { const key = p[0] + 'x' + p[1]; if (!seen.has(key) && p[0] <= 100 && p[1] <= 100) { seen.add(key); deduped.push(p); } }
			deduped.sort((a, b) => (a[0] * a[1]) - (b[0] * b[1]));
			const prev = `${puzzleSizeX}x${puzzleSizeY}`;
			difficultySelect.innerHTML = deduped.map(([gx, gy]) => `<option value="${gx}x${gy}">${gx}×${gy}</option>`).join('');
			const first = deduped[0];
			const toSelect = difficultySelect.querySelector(`option[value="${prev}"]`) ? prev : `${first[0]}x${first[1]}`;
			difficultySelect.value = toSelect;
			const [gx, gy] = toSelect.split('x').map(Number);
			puzzleSizeX = gx; puzzleSizeY = gy;
		}

		/* ================================
		   Debug helpers
		================================= */
		function ts() { return new Date().toISOString().slice(11, 23); }
		function log(...args) { if (!DEBUG_ENABLED) return; const line = `[${ts()}] ${args.map(a => typeof a === 'object' ? JSON.stringify(a) : String(a)).join(' ')}`; console.log(...args); if (debugLogEl) { debugLogEl.textContent += line + '\n'; debugLogEl.scrollTop = debugLogEl.scrollHeight; } }
		function clearLog() { if (DEBUG_ENABLED && debugLogEl) debugLogEl.textContent = ''; }
		function setDebugUI(visible) { DEBUG_ENABLED = visible; debugHud.style.display = visible ? 'block' : 'none'; if (visible) { toggleBitmap.checked = USE_BITMAP; toggleCopy.checked = USE_COMPOSITE_COPY; debugEnv.textContent = `UA: ${navigator.userAgent}\ncreateImageBitmap: ${!!window.createImageBitmap}\ncolorSpace: ${'colorSpace' in CanvasRenderingContext2D.prototype ? 'yes' : 'no'}\ngetImageData: ${typeof CanvasRenderingContext2D.prototype.getImageData}\n`; } }

		/* ================================
		   UI Events
		================================= */
		// Dark mode (persist in localStorage)
		const DARK_KEY = 'puzzle.dark';
		function applyDark(pref) { document.documentElement.classList.toggle('dark', !!pref); darkToggle.checked = !!pref; localStorage.setItem(DARK_KEY, pref ? '1' : ''); }
		applyDark(localStorage.getItem(DARK_KEY) === '1' || (matchMedia('(prefers-color-scheme: dark)').matches));
		darkToggle.addEventListener('change', () => applyDark(darkToggle.checked));

		uiDebugToggle.addEventListener('change', () => setDebugUI(uiDebugToggle.checked));

		// Animation speed slider
		function setAnimSpeed(v) { currentSpeed = Math.max(0, Math.min(1, v)); animSpeedLabel.textContent = currentSpeed.toFixed(2) + '×'; updateAnimationPipelines(); }
		animSpeedSlider.addEventListener('input', () => setAnimSpeed(parseFloat(animSpeedSlider.value)));
		setAnimSpeed(1);

		imageLoader.addEventListener('change', e => { const file = e.target.files?.[0]; if (!file) return; srcFile = file; loadFromFile(file); });
		difficultySelect.addEventListener('change', () => { const [gx, gy] = difficultySelect.value.split('x').map(Number); puzzleSizeX = gx; puzzleSizeY = gy; log('difficulty.change → rebuild'); createPuzzle(); });
		scrambleBtn.addEventListener('click', () => { if (frameSource?.ready) createPuzzle(); });

		let resizeRAF = null;
		window.addEventListener('resize', () => {
			if (!frameSource?.ready) return;
			cancelAnimationFrame(resizeRAF);
			resizeRAF = requestAnimationFrame(() => { log('window.resize → rebuild'); buildDifficultyOptions(); createPuzzle(); });
		});

		/* ================================
		   Debug HUD wiring
		================================= */
		toggleBitmap.addEventListener('change', () => { USE_BITMAP = toggleBitmap.checked; log('TOGGLE USE_BITMAP', USE_BITMAP); if (srcFile) loadFromFile(srcFile); });
		toggleCopy.addEventListener('change', () => { USE_COMPOSITE_COPY = toggleCopy.checked; log('TOGGLE composite=copy', USE_COMPOSITE_COPY); if (frameSource?.ready) createPuzzle(); });
		btnSelfTest.addEventListener('click', selfTestCanvas);

		const btnRawDraw = document.createElement('button');
		btnRawDraw.textContent = 'Raw draw src → HUD';
		btnRawDraw.onclick = () => {
			if (!frameSource?.ready) return;
			const srcEl = frameSource.sourceElement ? frameSource.sourceElement() : frameSource.currentFrameCanvas();
			const w = srcEl.width || srcEl.naturalWidth || 256; const h = srcEl.height || srcEl.naturalHeight || 256;
			const c = debugPaddedCanvas; c.width = w; c.height = h; const ctx = c.getContext('2d'); ctx.clearRect(0, 0, w, h); ctx.fillStyle = '#ff00ff88'; ctx.fillRect(0, 0, w, h);
			try { ctx.drawImage(srcEl, 0, 0, w, h); } catch (e) { log('Raw draw ERROR', String(e)); }
			try { const p = ctx.getImageData((w / 2) | 0, (h / 2) | 0, 1, 1).data; log('Raw draw probe (center)', Array.from(p)); } catch (e) { log('Raw draw probe ERROR', String(e)); }
		};
		document.getElementById('debug-cta').appendChild(btnRawDraw);

		/* ================================
		   IFrameSource (StaticImageSource / GifFrameSource)
		================================= */
		function fileToDataURL(file) { return new Promise((res, rej) => { const r = new FileReader(); r.onerror = () => rej(r.error); r.onload = () => res(r.result); r.readAsDataURL(file); }); }
		function loadHTMLImage(src) { return new Promise((res, rej) => { const img = new Image(); img.decoding = 'async'; img.onload = async () => { try { if (img.decode) await img.decode(); } catch { } res(img); }; img.onerror = rej; img.src = src; }); }

		class StaticImageSource {
			constructor(width, height, source) { this.ready = true; this.animated = false; this.width = width; this.height = height; this._element = source; this._canvas = document.createElement('canvas'); this._canvas.width = width; this._canvas.height = height; const ctx = this._canvas.getContext('2d'); ctx.drawImage(source, 0, 0, width, height); }
			currentFrameCanvas() { return this._canvas; }
			sourceElement() { return this._element; }
			start() { } stop() { }
			destroy() { }
		}

		class GifFrameSource {
			constructor(file) {
				this.ready = false; this.animated = true; this.width = 1; this.height = 1; this._canvas = document.createElement('canvas'); this._animator = null; this._objectURL = URL.createObjectURL(file); this._onReady = null; this._onDraw = () => { }; // callback when gifler draws
				gifler(this._objectURL).get((animator) => { this._animator = animator; animator.onDrawFrame = (ctx, frame) => { ctx.globalCompositeOperation = 'source-over'; const x = ('x' in frame) ? frame.x : (frame.dims?.left || 0); const y = ('y' in frame) ? frame.y : (frame.dims?.top || 0); ctx.drawImage(frame.buffer, x, y); this._onDraw(); }; animator.animateInCanvas(this._canvas, true); this.width = this._canvas.width; this.height = this._canvas.height; this.ready = true; if (this._onReady) this._onReady(); });
			}
			currentFrameCanvas() { return this._canvas; }
			sourceElement() { return this._canvas; }
			onReady(cb) { this._onReady = cb; if (this.ready) cb(); }
			onDraw(cb) { this._onDraw = cb || (() => { }); }
			start() { if (this._animator) this._animator.start(); }
			stop() { if (this._animator) this._animator.stop(); }
			destroy() { try { this.stop(); } catch { } if (this._objectURL) URL.revokeObjectURL(this._objectURL); }
		}

		/* ================================
		   Load & Decode
		================================= */
		async function loadFromFile(file) {
			clearLog(); stopRepaintLoop(); try { frameSource?.destroy?.(); } catch { }
			puzzleSolved = false; scrambleBtn.disabled = true; frameSource = null;
			log('onSelectFile', { name: file.name, size: file.size, type: file.type });

			if (file.type === 'image/gif') {
				try {
					frameSource = new GifFrameSource(file);
					frameSource.onReady(() => {
						imageAspectRatio = frameSource.width / frameSource.height;
						buildDifficultyOptions(); scrambleBtn.disabled = false; createPuzzle();
						frameSource.onDraw(() => { /* gifler keeps its own timing; repaint loop samples */ });
						updateAnimationPipelines();
					});
				} catch (err) { log('GIF DECODE ERROR', String(err)); alert('Failed to decode GIF.'); return; }
				return;
			}

			try {
				let srcBitmap = null, srcImage = null;
				if (USE_BITMAP && window.createImageBitmap) {
					srcBitmap = await createImageBitmap(file, { imageOrientation: 'from-image', premultiplyAlpha: 'premultiply', colorSpaceConversion: 'default' });
					imageAspectRatio = srcBitmap.width / srcBitmap.height; log('createImageBitmap OK', { w: srcBitmap.width, h: srcBitmap.height });
					frameSource = new StaticImageSource(srcBitmap.width, srcBitmap.height, srcBitmap);
				} else {
					const dataURL = await fileToDataURL(file); srcImage = await loadHTMLImage(dataURL);
					imageAspectRatio = srcImage.naturalWidth / srcImage.naturalHeight; log('HTMLImage loaded', { w: srcImage.naturalWidth, h: srcImage.naturalHeight });
					frameSource = new StaticImageSource(srcImage.naturalWidth, srcImage.naturalHeight, srcImage);
				}
			} catch (err) { log('DECODE ERROR', String(err)); alert('Failed to decode image.'); return; }

			buildDifficultyOptions(); scrambleBtn.disabled = false; createPuzzle();
		}

		/* ================================
		   Padded Source Builder
		================================= */
		function buildPaddedSource(gridX, gridY, token) {
			const srcEl = frameSource.sourceElement ? frameSource.sourceElement() : frameSource.currentFrameCanvas();
			const srcW = srcEl.width || srcEl.naturalWidth; const srcH = srcEl.height || srcEl.naturalHeight;
			const paddedW = Math.ceil(srcW / gridX) * gridX; const paddedH = Math.ceil(srcH / gridY) * gridY;
			const canvas = document.createElement('canvas'); canvas.width = paddedW; canvas.height = paddedH; const ctx = canvas.getContext('2d');
			const offsetX = Math.floor((paddedW - srcW) / 2); const offsetY = Math.floor((paddedH - srcH) / 2);
			let drew = attemptDrawTo(ctx, srcEl, offsetX, offsetY, srcW, srcH, 'source-over');
			if (!drew && USE_COMPOSITE_COPY) { drew = attemptDrawTo(ctx, srcEl, offsetX, offsetY, srcW, srcH, 'copy'); }
			return { canvas, width: paddedW, height: paddedH };
		}

		function rebuildSliceSourceFromCurrentFrame(gridX, gridY) {
			const srcEl = frameSource.sourceElement ? frameSource.sourceElement() : frameSource.currentFrameCanvas();
			const srcW = srcEl.width || srcEl.naturalWidth; const srcH = srcEl.height || srcEl.naturalHeight;
			const paddedW = Math.ceil(srcW / gridX) * gridX; const paddedH = Math.ceil(srcH / gridY) * gridY;
			if (!paddedReuseCanvas) paddedReuseCanvas = document.createElement('canvas');
			if (paddedReuseCanvas.width !== paddedW || paddedReuseCanvas.height !== paddedH) { paddedReuseCanvas.width = paddedW; paddedReuseCanvas.height = paddedH; }
			const ctx = paddedReuseCanvas.getContext('2d'); ctx.clearRect(0, 0, paddedW, paddedH);
			const offsetX = Math.floor((paddedW - srcW) / 2); const offsetY = Math.floor((paddedH - srcH) / 2);
			ctx.drawImage(srcEl, offsetX, offsetY, srcW, srcH);
			sliceSourceCanvas = paddedReuseCanvas; sliceSourceW = paddedW; sliceSourceH = paddedH;
		}

		function attemptDrawTo(ctx, srcDrawable, x, y, w, h, compOp = 'source-over') {
			ctx.save(); ctx.globalCompositeOperation = compOp; ctx.clearRect(x, y, w, h); let drew = false; try { ctx.drawImage(srcDrawable, x, y, w, h); } catch (e) { log('attemptDrawTo ERROR', { compOp, err: String(e) }); }
			try { const mid = ctx.getImageData((x + (w / 2)) | 0, (y + (h / 2)) | 0, 1, 1).data; drew = mid[3] > 0; } catch (e) { log('probe ERROR', String(e)); }
			ctx.restore(); log('attemptDrawTo', { compOp, drew }); return drew;
		}

		/* ================================
		   Build / Render
		================================= */
		function createPuzzle() {
			const myToken = ++buildToken; log('createPuzzle start', { token: myToken });
			pieceGroups = []; puzzleSolved = false;
			const container = puzzleBoard.parentElement; const containerWidth = container.clientWidth; const containerHeight = container.clientHeight;
			if (containerWidth < 10 || containerHeight < 10) { requestAnimationFrame(() => { if (myToken === buildToken) createPuzzle(); }); return; }
			puzzleBoard.innerHTML = '';
			assemblyArea = document.createElement('div'); assemblyArea.id = 'assembly-area'; puzzleBoard.appendChild(assemblyArea); puzzleBoard.appendChild(boardPlaceholder); puzzleBoard.appendChild(winMessage);
			winMessage.classList.remove('show'); boardPlaceholder.style.display = 'none';

			const padded = buildPaddedSource(puzzleSizeX, puzzleSizeY, myToken); if (myToken !== buildToken) return;
			if (frameSource.animated) {
				if (!paddedReuseCanvas) paddedReuseCanvas = document.createElement('canvas');
				paddedReuseCanvas.width = padded.width; paddedReuseCanvas.height = padded.height; const ctx = paddedReuseCanvas.getContext('2d'); ctx.clearRect(0, 0, padded.width, padded.height); ctx.drawImage(padded.canvas, 0, 0);
				sliceSourceCanvas = paddedReuseCanvas; sliceSourceW = paddedReuseCanvas.width; sliceSourceH = paddedReuseCanvas.height;
			} else { sliceSourceCanvas = padded.canvas; sliceSourceW = padded.width; sliceSourceH = padded.height; }

			const paddedAspect = sliceSourceW / sliceSourceH;

			// Give the player more space: use up to 90% of the board width/height
			const boardWidth = containerWidth; const boardHeight = containerHeight;
			puzzleBoard.style.width = `${boardWidth}px`; puzzleBoard.style.height = `${boardHeight}px`;

			let assemblyWidth = Math.floor(boardWidth * 0.7); // larger than before
			let assemblyHeight = Math.round(assemblyWidth / paddedAspect);
			if (assemblyHeight > Math.floor(boardHeight * 0.85)) { assemblyHeight = Math.floor(boardHeight * 0.85); assemblyWidth = Math.round(assemblyHeight * paddedAspect); }

			pieceWidth = Math.max(1, Math.floor(assemblyWidth / puzzleSizeX));
			pieceHeight = Math.max(1, Math.floor(assemblyHeight / puzzleSizeY));
			assemblyWidth = pieceWidth * puzzleSizeX;
			assemblyHeight = pieceHeight * puzzleSizeY;

			const assemblyX = (boardWidth - assemblyWidth) / 2; const assemblyY = (boardHeight - assemblyHeight) / 2;
			Object.assign(assemblyArea.style, { width: `${assemblyWidth}px`, height: `${assemblyHeight}px`, left: `${assemblyX}px`, top: `${assemblyY}px` });

			const sw = sliceSourceW / puzzleSizeX; const sh = sliceSourceH / puzzleSizeY;
			for (let y = 0; y < puzzleSizeY; y++) {
				for (let x = 0; x < puzzleSizeX; x++) {
					if (myToken !== buildToken) return;
					const piece = createPieceCanvas(x, y, sw, sh); const group = createPieceGroup(piece);
					placeGroupRandomly(group, boardWidth, boardHeight, { x: assemblyX, y: assemblyY, width: assemblyWidth, height: assemblyHeight });
					puzzleBoard.appendChild(group.element); pieceGroups.push(group);
				}
			}
			log('createPuzzle done', { token: myToken, pieces: pieceGroups.length });
		}

		function createPieceCanvas(gridX, gridY, sw, sh) {
			const piece = document.createElement('canvas'); piece.className = 'puzzle-piece';
			piece.width = Math.max(1, pieceWidth); piece.height = Math.max(1, pieceHeight);
			Object.assign(piece.style, { width: `${pieceWidth}px`, height: `${pieceHeight}px`, left: '0px', top: '0px' });
			piece.dataset.correctX = gridX; piece.dataset.correctY = gridY;
			renderPieceFromCurrentFrame(piece, gridX, gridY, sw, sh);
			return piece;
		}

		function renderPieceFromCurrentFrame(piece, gridX, gridY, sw, sh) {
			const ctx = piece.getContext('2d'); ctx.clearRect(0, 0, piece.width, piece.height);
			try { ctx.drawImage(sliceSourceCanvas, gridX * sw, gridY * sh, sw, sh, 0, 0, piece.width, piece.height); } catch (err) { log('ERROR drawImage piece', { gridX, gridY, err: String(err) }); }
		}

		function repaintAllPiecesFromSlice() {
			const sw = sliceSourceW / puzzleSizeX; const sh = sliceSourceH / puzzleSizeY;
			for (const group of pieceGroups) { for (const piece of group.pieces) { const gx = parseInt(piece.dataset.correctX, 10), gy = parseInt(piece.dataset.correctY, 10); renderPieceFromCurrentFrame(piece, gx, gy, sw, sh); } }
		}

		/* ================================
		   Animation / Repaint pipeline
		================================= */
		function startRepaintLoop() {
			if (repaintRunning) return; repaintRunning = true; let last = performance.now(); const BASE_INTERVAL = 100; // ms
			const loop = (t) => {
				if (!repaintRunning) return; const interval = (currentSpeed <= 0) ? Infinity : (BASE_INTERVAL / currentSpeed);
				if (t - last >= interval) { if (frameSource?.animated) { rebuildSliceSourceFromCurrentFrame(puzzleSizeX, puzzleSizeY); repaintAllPiecesFromSlice(); } last = t; }
				animRAF = requestAnimationFrame(loop);
			}; animRAF = requestAnimationFrame(loop);
		}

		function stopRepaintLoop() { repaintRunning = false; if (animRAF) cancelAnimationFrame(animRAF); animRAF = null; }

		function updateAnimationPipelines() {
			if (!frameSource?.animated) return; // static images unaffected
			if (currentSpeed === 0) { // fully paused
				stopRepaintLoop(); try { frameSource.stop(); } catch { }
			} else {
				// ensure animator is running; repaint at our chosen cadence
				try { frameSource.start(); } catch { }
				startRepaintLoop();
			}
		}

		/* ================================
		   Dragging / Merge
		================================= */
		function createPieceGroup(initialPiece) {
			const groupElement = document.createElement('div'); groupElement.className = 'puzzle-group'; groupElement.appendChild(initialPiece);
			const group = { element: groupElement, pieces: [initialPiece], minX: parseInt(initialPiece.dataset.correctX), minY: parseInt(initialPiece.dataset.correctY), widthInPieces: 1, heightInPieces: 1 };
			addDragListeners(group); return group;
		}

		function placeGroupRandomly(group, boardW, boardH, assemblyRect) {
			const pw = pieceWidth, ph = pieceHeight; let x, y; const placementArea = Math.floor(Math.random() * 4); const safeW = Math.max(0, boardW - pw); const safeH = Math.max(0, boardH - ph);
			switch (placementArea) {
				case 0: x = Math.random() * safeW; y = Math.max(0, Math.random() * Math.max(0, assemblyRect.y - ph)); break;
				case 1: x = Math.random() * safeW; y = (assemblyRect.y + assemblyRect.height) + Math.random() * Math.max(0, boardH - (assemblyRect.y + assemblyRect.height) - ph); break;
				case 2: x = Math.max(0, Math.random() * Math.max(0, assemblyRect.x - pw)); y = Math.random() * safeH; break;
				default: x = (assemblyRect.x + assemblyRect.width) + Math.random() * Math.max(0, boardW - (assemblyRect.x + assemblyRect.width) - pw); y = Math.random() * safeH; break;
			}
			group.element.style.left = `${Math.max(0, x || 0)}px`; group.element.style.top = `${Math.max(0, y || 0)}px`;
		}

		function addDragListeners(group) {
			let offsetX, offsetY; const groupElement = group.element;
			function onDragStart(e) {
				if (puzzleSolved) return; e.preventDefault(); groupElement.classList.add('dragging'); puzzleBoard.appendChild(groupElement);
				const t = e.touches?.[0] || e; const rect = groupElement.getBoundingClientRect(); offsetX = (t.clientX - rect.left); offsetY = (t.clientY - rect.top);
				// Pause GIF while dragging (optional)
				if (pauseOnDragCheckbox.checked && frameSource?.animated) { animatorWasRunning = currentSpeed > 0; try { frameSource.stop(); } catch { } }
				document.addEventListener('mousemove', onDragMove); document.addEventListener('mouseup', onDragEnd); document.addEventListener('touchmove', onDragMove, { passive: false }); document.addEventListener('touchend', onDragEnd);
			}
			function onDragMove(e) {
				e.preventDefault(); const t = e.touches?.[0] || e; const boardRect = puzzleBoard.getBoundingClientRect();
				let newX = t.clientX - boardRect.left - offsetX; let newY = t.clientY - boardRect.top - offsetY;
				const groupWidth = group.widthInPieces * pieceWidth; const groupHeight = group.heightInPieces * pieceHeight; const maxX = puzzleBoard.clientWidth - groupWidth; const maxY = puzzleBoard.clientHeight - groupHeight;
				newX = Math.max(0, Math.min(newX, maxX)); newY = Math.max(0, Math.min(newY, maxY)); groupElement.style.left = `${newX | 0}px`; groupElement.style.top = `${newY | 0}px`;
			}
			function onDragEnd() {
				groupElement.classList.remove('dragging'); document.removeEventListener('mousemove', onDragMove); document.removeEventListener('mouseup', onDragEnd); document.removeEventListener('touchmove', onDragMove); document.removeEventListener('touchend', onDragEnd);
				// Resume GIF if we paused it
				if (pauseOnDragCheckbox.checked && frameSource?.animated) { if (animatorWasRunning) { try { frameSource.start(); } catch { } } updateAnimationPipelines(); }
				checkForMultiSnap(group);
			}
			groupElement.addEventListener('mousedown', onDragStart); groupElement.addEventListener('touchstart', onDragStart, { passive: true });
		}

		function checkForMultiSnap(draggedGroup) { let groupToCheck = draggedGroup; let madeAMerge = true; while (madeAMerge) { madeAMerge = false; for (let i = pieceGroups.length - 1; i >= 0; i--) { const stationaryGroup = pieceGroups[i]; if (stationaryGroup === groupToCheck) continue; const snapResult = findAndPerformSnap(groupToCheck, stationaryGroup); if (snapResult) { groupToCheck = stationaryGroup; madeAMerge = true; break; } } } }

		function findAndPerformSnap(draggedGroup, stationaryGroup) { for (const dp of draggedGroup.pieces) { for (const sp of stationaryGroup.pieces) { const dir = checkAdjacency(dp, sp); if (dir) { alignAndMerge(draggedGroup, stationaryGroup, dp, sp, dir); return true; } } } return false; }

		function checkAdjacency(dp, sp) {
			const dpX = parseInt(dp.dataset.correctX), dpY = parseInt(dp.dataset.correctY); const spX = parseInt(sp.dataset.correctX), spY = parseInt(sp.dataset.correctY);
			const dr = dp.getBoundingClientRect(); const sr = sp.getBoundingClientRect();
			if (dpX === spX + 1 && dpY === spY && Math.abs(dr.left - sr.right) < SNAP_TOLERANCE && Math.abs(dr.top - sr.top) < SNAP_TOLERANCE) return 'right';
			if (dpX === spX - 1 && dpY === spY && Math.abs(dr.right - sr.left) < SNAP_TOLERANCE && Math.abs(dr.top - sr.top) < SNAP_TOLERANCE) return 'left';
			if (dpY === spY + 1 && dpX === spX && Math.abs(dr.top - sr.bottom) < SNAP_TOLERANCE && Math.abs(dr.left - sr.left) < SNAP_TOLERANCE) return 'down';
			if (dpY === spY - 1 && dpX === spX && Math.abs(dr.bottom - sr.top) < SNAP_TOLERANCE && Math.abs(dr.left - sr.left) < SNAP_TOLERANCE) return 'up';
			return null;
		}

		function alignAndMerge(dg, sg, dp, sp, direction) {
			const sgPos = { left: sg.element.offsetLeft, top: sg.element.offsetTop };
			const spOff = { left: parseFloat(sp.style.left), top: parseFloat(sp.style.top) };
			const dpOff = { left: parseFloat(dp.style.left), top: parseFloat(dp.style.top) };
			let targetLeft, targetTop;
			switch (direction) {
				case 'right': targetLeft = sgPos.left + spOff.left + pieceWidth - dpOff.left; targetTop = sgPos.top + spOff.top - dpOff.top; break;
				case 'left': targetLeft = sgPos.left + spOff.left - pieceWidth - dpOff.left; targetTop = sgPos.top + spOff.top - dpOff.top; break;
				case 'down': targetLeft = sgPos.left + spOff.left - dpOff.left; targetTop = sgPos.top + spOff.top + pieceHeight - dpOff.top; break;
				case 'up': targetLeft = sgPos.left + spOff.left - dpOff.left; targetTop = sgPos.top + spOff.top - pieceHeight - dpOff.top; break;
			}
			dg.element.style.left = `${targetLeft | 0}px`; dg.element.style.top = `${targetTop | 0}px`;
			mergeGroups(dg, sg);
		}

		function mergeGroups(dg, sg) {
			const dEl = dg.element; const sEl = sg.element; const offsetX = dEl.offsetLeft - sEl.offsetLeft; const offsetY = dEl.offsetTop - sEl.offsetTop;
			while (dEl.firstChild) { const piece = dEl.firstChild; piece.style.left = `${(parseFloat(piece.style.left) + offsetX) | 0}px`; piece.style.top = `${(parseFloat(piece.style.top) + offsetY) | 0}px`; sEl.appendChild(piece); sg.pieces.push(piece); }
			let minX = Infinity, minY = Infinity; for (const p of sg.pieces) { const l = parseFloat(p.style.left), t = parseFloat(p.style.top); if (l < minX) minX = l; if (t < minY) minY = t; }
			if (minX || minY) { sEl.style.left = `${(sEl.offsetLeft + minX) | 0}px`; sEl.style.top = `${(sEl.offsetTop + minY) | 0}px`; for (const p of sg.pieces) { p.style.left = `${(parseFloat(p.style.left) - minX) | 0}px`; p.style.top = `${(parseFloat(p.style.top) - minY) | 0}px`; } }
			puzzleBoard.removeChild(dEl); pieceGroups = pieceGroups.filter(g => g !== dg);
			sg.minX = Math.min(sg.minX, dg.minX); sg.minY = Math.min(sg.minY, dg.minY);
			let maxX = sg.minX, maxY = sg.minY; for (const p of sg.pieces) { const px = parseInt(p.dataset.correctX), py = parseInt(p.dataset.correctY); if (px > maxX) maxX = px; if (py > maxY) maxY = py; }
			sg.widthInPieces = maxX - sg.minX + 1; sg.heightInPieces = maxY - sg.minY + 1; checkWinCondition();
		}

		function checkWinCondition() {
			if (pieceGroups.length === 1 && pieceGroups[0].pieces.length === puzzleSizeX * puzzleSizeY) {
				const finalGroup = pieceGroups[0]; const finalX = assemblyArea.offsetLeft - (finalGroup.minX * pieceWidth); const finalY = assemblyArea.offsetTop - (finalGroup.minY * pieceHeight);
				finalGroup.element.style.transition = 'left .5s, top .5s, filter .5s'; finalGroup.element.style.left = `${finalX}px`; finalGroup.element.style.top = `${finalY}px`; finalGroup.element.style.cursor = 'default'; finalGroup.element.style.zIndex = '5'; finalGroup.element.style.filter = 'none';
				puzzleSolved = true; winMessage.classList.add('show');
			}
		}

		/* ================================
		   Debug: Canvas self-test
		================================= */
		function selfTestCanvas() { const w = 256, h = 256; const c = debugPaddedCanvas; c.width = w; c.height = h; const ctx = c.getContext('2d'); const g = ctx.createLinearGradient(0, 0, w, h); g.addColorStop(0, '#0ea5e9'); g.addColorStop(1, '#22c55e'); ctx.fillStyle = g; ctx.fillRect(0, 0, w, h); ctx.fillStyle = '#fff'; ctx.fillRect(124, 124, 8, 8); const dot = ctx.getImageData(128, 128, 1, 1).data; log('SELF-TEST pixel', Array.from(dot)); }
	</script>
</body>

</html>