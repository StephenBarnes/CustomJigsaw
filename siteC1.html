<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0" />
	<title>Image Jigsaw Puzzle</title>
	<script src="https://cdn.tailwindcss.com"></script>
	<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
	<style>
		body {
			font-family: 'Inter', sans-serif;
			touch-action: none;
			overflow: hidden
		}

		.puzzle-group {
			position: absolute;
			cursor: grab;
			z-index: 10;
			filter: drop-shadow(0 2px 4px rgba(0, 0, 0, .25));
			transition: filter .1s, z-index 0s .1s
		}

		.puzzle-group.dragging {
			cursor: grabbing;
			z-index: 20;
			filter: drop-shadow(0 10px 15px rgba(0, 0, 0, .25))
		}

		.puzzle-piece {
			position: absolute;
			border: none;
			transition: transform .1s;
			background: rgba(0, 0, 0, 0.02)
				/* faint bg to see bounds even if slice is blank */
		}

		.puzzle-group.dragging .puzzle-piece {
			transform: scale(1.025)
		}

		#puzzle-board {
			background: #f0f4f8;
			position: relative;
			overflow: hidden;
			border-radius: .5rem;
			box-shadow: inset 0 2px 4px rgba(0, 0, 0, .06)
		}

		#assembly-area {
			position: absolute;
			border: 2px dashed #cbd5e1;
			box-sizing: border-box;
			pointer-events: none
		}

		.control-panel {
			background: #fff;
			padding: 1.5rem;
			border-radius: .75rem;
			box-shadow: 0 10px 15px -3px rgba(0, 0, 0, .1), 0 4px 6px -2px rgba(0, 0, 0, .05)
		}

		#win-message {
			position: absolute;
			bottom: 0;
			left: 0;
			width: 100%;
			display: flex;
			justify-content: center;
			background: linear-gradient(to top, rgba(0, 0, 0, .6), transparent);
			padding: 2rem 1rem;
			box-sizing: border-box;
			opacity: 0;
			transform: translateY(100%);
			pointer-events: none;
			transition: opacity .5s, transform .5s
		}

		#win-message.show {
			opacity: 1;
			transform: translateY(0);
			pointer-events: auto
		}

		.win-message-content {
			text-align: center;
			padding: 1.5rem 3rem;
			background: #2f855a;
			border-radius: .75rem;
			box-shadow: 0 10px 25px rgba(0, 0, 0, .3)
		}

		.win-message-content h2 {
			font-size: 3rem;
			font-weight: 700;
			color: #fff
		}

		/* DEBUG HUD */
		#debug-hud {
			position: fixed;
			right: 12px;
			bottom: 12px;
			background: rgba(0, 0, 0, .88);
			color: #e2e8f0;
			border: 1px solid rgba(255, 255, 255, .15);
			border-radius: .75rem;
			padding: .75rem;
			max-width: 46vw;
			max-height: 64vh;
			overflow: auto;
			z-index: 9999;
			display: none
		}

		#debug-hud h3 {
			font-weight: 700;
			margin-bottom: .25rem
		}

		#debug-hud pre {
			font-family: ui-monospace, SFMono-Regular, Menlo, monospace;
			font-size: 12px;
			line-height: 1.3;
			white-space: pre-wrap;
			word-break: break-word
		}

		#debug-row {
			display: flex;
			gap: .75rem;
			align-items: flex-start;
			margin-top: .5rem
		}

		#debug-padded {
			background: repeating-conic-gradient(#111 0% 25%, #222 0% 50%) 50%/20px 20px;
			outline: 1px solid #475569;
			max-width: 24vw;
			height: auto
		}

		#debug-controls {
			display: flex;
			gap: .5rem;
			align-items: center;
			margin: .25rem 0 .5rem
		}

		#debug-cta button {
			font-size: 12px;
			border: 1px solid #64748b;
			padding: .25rem .5rem;
			border-radius: .25rem;
			background: #0f172a;
			color: #e2e8f0
		}
	</style>
</head>

<body class="bg-slate-100 text-slate-800 flex flex-col items-center justify-center h-screen p-4">
	<div class="w-full max-w-7xl mx-auto flex flex-col h-full">
		<header class="text-center mb-4 shrink-0">
			<h1 class="text-4xl font-bold text-slate-700">Image Jigsaw Puzzle</h1>
			<p class="text-slate-500 mt-2">Select an image, then assemble the puzzle in the center.</p>
		</header>
		<div class="control-panel mb-4 flex flex-col sm:flex-row items-center justify-center gap-4 shrink-0">
			<div>
				<label for="image-loader"
					class="cursor-pointer bg-blue-500 text-white font-bold py-2 px-4 rounded-md hover:bg-blue-600 transition-colors">Select
					Image</label>
				<input type="file" id="image-loader" class="hidden" accept="image/png, image/jpeg">
			</div>
			<div class="flex items-center gap-3">
				<label for="puzzle-size" class="font-medium">Difficulty:</label>
				<input type="range" id="puzzle-size" min="3" max="12" value="4" class="w-32 cursor-pointer">
				<span id="size-label" class="font-semibold w-12 text-center">4x4</span>
			</div>
			<button id="scramble-btn"
				class="bg-green-500 text-white font-bold py-2 px-4 rounded-md hover:bg-green-600 transition-colors disabled:bg-gray-400 disabled:cursor-not-allowed"
				disabled>Re-Scramble</button>
		</div>
		<main id="puzzle-board-container"
			class="flex-grow w-full flex items-center justify-center relative bg-white rounded-lg shadow-md overflow-hidden">
			<div id="puzzle-board">
				<p id="board-placeholder" class="text-slate-400 absolute inset-0 flex items-center justify-center">The
					puzzle board is empty</p>
				<div id="win-message">
					<div class="win-message-content">
						<h2>Puzzle Solved!</h2>
					</div>
				</div>
			</div>
		</main>
	</div>
	<!-- DEBUG HUD -->
	<div id="debug-hud">
		<h3>Debug</h3>
		<div id="debug-controls">
			<label class="text-xs opacity-80"><input id="toggle-bitmap" type="checkbox"> use ImageBitmap</label>
			<label class="text-xs opacity-80"><input id="toggle-copy" type="checkbox" checked> composite=copy</label>
			<label class="text-xs opacity-80"><input id="toggle-lastditch" type="checkbox" checked> enable
				last-ditch</label>
		</div>
		<div id="debug-cta">
			<button id="btn-selftest">Run Canvas Self-Test</button>
		</div>
		<pre id="debug-env"></pre>
		<pre id="debug-log"></pre>
		<div id="debug-row">
			<canvas id="debug-padded"></canvas>
			<pre id="debug-metrics"></pre>
		</div>
	</div>
	<script>
		/* ================================
		CONFIG / STATE
		================================ */
		const DEBUG = false;
		let USE_BITMAP = false; // can be toggled in HUD
		let USE_COMPOSITE_COPY = true; // toggled in HUD
		let ENABLE_LAST_DITCH = true; // toggled in HUD
		const imageLoader = document.getElementById('image-loader');
		const puzzleSizeSlider = document.getElementById('puzzle-size');
		const sizeLabel = document.getElementById('size-label');
		const scrambleBtn = document.getElementById('scramble-btn');
		const puzzleBoard = document.getElementById('puzzle-board');
		const boardPlaceholder = document.getElementById('board-placeholder');
		const winMessage = document.getElementById('win-message');
		const debugHud = document.getElementById('debug-hud');
		const debugEnv = document.getElementById('debug-env');
		const debugLogEl = document.getElementById('debug-log');
		const debugPaddedCanvas = document.getElementById('debug-padded');
		const debugMetricsEl = document.getElementById('debug-metrics');
		const toggleBitmap = document.getElementById('toggle-bitmap');
		const toggleCopy = document.getElementById('toggle-copy');
		const toggleLast = document.getElementById('toggle-lastditch');
		const btnSelfTest = document.getElementById('btn-selftest');
		if (DEBUG) {
			debugHud.style.display = 'block';
			toggleBitmap.checked = USE_BITMAP;
			toggleCopy.checked = USE_COMPOSITE_COPY;
			toggleLast.checked = ENABLE_LAST_DITCH;
			toggleBitmap.addEventListener('change', () => { USE_BITMAP = toggleBitmap.checked; log('TOGGLE USE_BITMAP', USE_BITMAP); if (srcFile) loadFromFile(srcFile); });
			toggleCopy.addEventListener('change', () => { USE_COMPOSITE_COPY = toggleCopy.checked; log('TOGGLE composite=copy', USE_COMPOSITE_COPY); if (srcReady) createPuzzle(); });
			toggleLast.addEventListener('change', () => { ENABLE_LAST_DITCH = toggleLast.checked; log('TOGGLE last-ditch', ENABLE_LAST_DITCH); });
			btnSelfTest.addEventListener('click', selfTestCanvas);
			debugEnv.textContent =
				`UA: ${navigator.userAgent}
createImageBitmap: ${!!window.createImageBitmap}
colorSpace: ${'colorSpace' in CanvasRenderingContext2D.prototype ? 'yes' : 'no'}
getImageData: ${typeof CanvasRenderingContext2D.prototype.getImageData}
`;
		}
		function ts() { return new Date().toISOString().slice(11, 23); }
		function log(...args) {
			if (!DEBUG) return;
			const line = `[${ts()}] ${args.map(a => (typeof a === 'object' ? JSON.stringify(a) : String(a))).join(' ')}`;
			console.log(...args);
			debugLogEl.textContent += line + '\n';
			debugLogEl.scrollTop = debugLogEl.scrollHeight;
		}
		function clearLog() { if (DEBUG) debugLogEl.textContent = ''; }
		let assemblyArea = null;
		let srcFile = null; // keep the File around
		let srcBitmap = null; // ImageBitmap (preferred in this pipeline)
		let srcImage = null; // fallback HTMLImageElement
		let srcReady = false;
		let imageAspectRatio = 1;
		let sliceSourceCanvas = null;
		let sliceSourceW = 0;
		let sliceSourceH = 0;
		let pieceGroups = [];
		let basePuzzleSize = 4;
		let puzzleSizeX = 4;
		let puzzleSizeY = 4;
		let pieceWidth = 0;
		let pieceHeight = 0;
		let puzzleSolved = false;
		const SNAP_TOLERANCE = 25;
		let buildToken = 0;
		/* ================================
		 EVENTS
		================================ */
		imageLoader.addEventListener('change', e => {
			const file = e.target.files?.[0];
			if (!file) return;
			srcFile = file;
			loadFromFile(file);
		});
		puzzleSizeSlider.addEventListener('input', e => {
			basePuzzleSize = parseInt(e.target.value);
			if (!srcReady) { sizeLabel.textContent = `${basePuzzleSize}x${basePuzzleSize}`; return; }
			updatePuzzleDimensions();
			requestAnimationFrame(() => {
				log('slider.input → rebuild');
				createPuzzle();
			});
		});
		scrambleBtn.addEventListener('click', () => { if (srcReady) createPuzzle(); });
		let resizeRAF = null;
		window.addEventListener('resize', () => {
			if (!srcReady) return;
			cancelAnimationFrame(resizeRAF);
			resizeRAF = requestAnimationFrame(() => { log('window.resize → rebuild'); createPuzzle(); });
		});
		/* ================================
		 PIPELINE: Load & Decode
		 Prefer ImageBitmap(file) → robust & CORS-free.
		================================ */
		async function loadFromFile(file) {
			clearLog();
			srcReady = false;
			scrambleBtn.disabled = true;
			log('onSelectFile', { name: file.name, size: file.size });
			srcBitmap = null;
			srcImage = null;
			try {
				if (USE_BITMAP && window.createImageBitmap) {
					// Decode directly from the File Blob
					srcBitmap = await createImageBitmap(file, { imageOrientation: 'from-image', premultiplyAlpha: 'premultiply', colorSpaceConversion: 'default' });
					imageAspectRatio = srcBitmap.width / srcBitmap.height;
					log('createImageBitmap(file) OK', { w: srcBitmap.width, h: srcBitmap.height });
					srcReady = true;
				} else {
					// Fallback: stable <img> path via dataURL
					const dataURL = await fileToDataURL(file);
					srcImage = await loadHTMLImage(dataURL);
					imageAspectRatio = srcImage.naturalWidth / srcImage.naturalHeight;
					log('HTMLImageElement loaded', { w: srcImage.naturalWidth, h: srcImage.naturalHeight });
					srcReady = true;
				}
			} catch (err) {
				log('DECODE ERROR', String(err));
				srcReady = false;
			}
			if (!srcReady) {
				alert('Failed to decode image.');
				return;
			}
			updatePuzzleDimensions();
			scrambleBtn.disabled = false;
			createPuzzle();
		}
		function fileToDataURL(file) {
			return new Promise((res, rej) => {
				const r = new FileReader();
				r.onerror = () => rej(r.error);
				r.onload = () => res(r.result);
				r.readAsDataURL(file);
			});
		}
		function loadHTMLImage(src) {
			return new Promise((res, rej) => {
				const img = new Image();
				img.decoding = 'async';
				img.onload = async () => {
					try { if (img.decode) await img.decode(); } catch { }
					res(img);
				};
				img.onerror = rej;
				img.src = src;
			});
		}
		/* ================================
		 GRID & PADDING
		================================ */
		function updatePuzzleDimensions() {
			if (imageAspectRatio > 1) {
				puzzleSizeX = Math.round(basePuzzleSize * imageAspectRatio);
				puzzleSizeY = basePuzzleSize;
			} else {
				puzzleSizeX = basePuzzleSize;
				puzzleSizeY = Math.round(basePuzzleSize / imageAspectRatio);
			}
			puzzleSizeX = Math.max(3, puzzleSizeX);
			puzzleSizeY = Math.max(3, puzzleSizeY);
			sizeLabel.textContent = `${puzzleSizeX}x${puzzleSizeY}`;
			log('updatePuzzleDimensions', { base: basePuzzleSize, gridX: puzzleSizeX, gridY: puzzleSizeY, aspect: imageAspectRatio.toFixed(4) });
		}
		/* ================================
		 Build padded source with COMPOSITE COPY and verification
		================================ */
		function buildPaddedSource(gridX, gridY, token) {
			const srcW = srcBitmap ? srcBitmap.width : srcImage.naturalWidth;
			const srcH = srcBitmap ? srcBitmap.height : srcImage.naturalHeight;
			const paddedW = Math.ceil(srcW / gridX) * gridX;
			const paddedH = Math.ceil(srcH / gridY) * gridY;
			const canvas = document.createElement('canvas');
			canvas.width = paddedW; canvas.height = paddedH;
			const ctx = canvas.getContext('2d');
			// Canary background (checker look)
			ctx.fillStyle = '#ff00ff88';
			ctx.fillRect(0, 0, paddedW, paddedH);
			const offsetX = Math.floor((paddedW - srcW) / 2);
			const offsetY = Math.floor((paddedH - srcH) / 2);
			// 1) Default draw: source-over
			let drew = attemptDrawTo(ctx, offsetX, offsetY, srcW, srcH, 'source-over');
			// 2) If nothing landed, retry with 'copy'
			if (!drew) {
				drew = attemptDrawTo(ctx, offsetX, offsetY, srcW, srcH, 'copy');
			}
			// 3) If still nothing, recook the source via fetch→blob→bitmap and try again
			if (!drew) {
				drew = attemptDrawTo(ctx, offsetX, offsetY, srcW, srcH, 'source-over', /*forceRebitmap*/ true);
			}
			// Crosshair to show where we expected the top-left of the image
			if (DEBUG) {
				ctx.save();
				ctx.strokeStyle = '#ff0000cc';
				ctx.beginPath();
				ctx.moveTo(offsetX, offsetY - 6); ctx.lineTo(offsetX, offsetY + 6);
				ctx.moveTo(offsetX - 6, offsetY); ctx.lineTo(offsetX + 6, offsetY);
				ctx.stroke();
				ctx.restore();
			}
			// Mirror to HUD + probe
			let aTL = 0, aMid = 0;
			try {
				const tl = ctx.getImageData(Math.max(0, offsetX), Math.max(0, offsetY), 1, 1).data;
				const mid = ctx.getImageData((paddedW / 2) | 0, (paddedH / 2) | 0, 1, 1).data;
				aTL = tl[3]; aMid = mid[3];
				log('padded-samples', { TL: Array.from(tl), MID: Array.from(mid), sum: aTL + aMid });
			} catch (err) {
				log('getImageData ERROR', String(err));
			}
			if (DEBUG) {
				const dbg = debugPaddedCanvas;
				dbg.width = paddedW; dbg.height = paddedH;
				const dctx = dbg.getContext('2d');
				dctx.clearRect(0, 0, paddedW, paddedH);
				dctx.drawImage(canvas, 0, 0);
				debugMetricsEl.textContent =
					`Token: ${token}
Src: ${srcW}×${srcH}
Padded: ${paddedW}×${paddedH}
Grid: ${gridX}×${gridY}
Piece: ${(paddedW / gridX) | 0}×${(paddedH / gridY) | 0}
Samples: TL a=${aTL} MID a=${aMid} sum=${aTL + aMid}
Path: ${srcBitmap ? 'ImageBitmap(file/blob)' : 'HTMLImageElement(dataURL)'}
DrawOK: ${drew ? 'yes' : 'NO (used fallback)'}
`;
			}
			return { canvas, width: paddedW, height: paddedH };
		}
		async function makeBitmapFromCurrentFile() {
			// Re-decode via fetch→blob→bitmap to avoid edge cases
			if (!srcFile) return null;
			const blob = srcFile; // we already have a Blob (File)
			try {
				const bmp = await createImageBitmap(blob, { imageOrientation: 'from-image', premultiplyAlpha: 'default', colorSpaceConversion: 'default' });
				return bmp;
			} catch (e) {
				log('rebitmap FAIL', String(e));
				return null;
			}
		}
		// Attempts to draw the current source into ctx at (x,y). Returns true if alpha landed.
		function attemptDrawTo(ctx, x, y, w, h, compOp = 'source-over', forceRebitmap = false) {
			ctx.save();
			ctx.globalCompositeOperation = compOp;
			// Clear target rect first (so probes are accurate)
			ctx.clearRect(x, y, w, h);
			let drew = false;
			try {
				if (forceRebitmap && window.createImageBitmap) {
					// NOTE: this is sync-ish in our call site; if you prefer, you can make buildPaddedSource async.
					// For now, we use a microtask “spin” as a quick pragmatic step:
					const start = performance.now();
					const then = Date.now();
					// Simple async trampoline via Promise.resolve().then(...)
					let bmp = null;
					const done = () => {
						if (bmp) ctx.drawImage(bmp, x, y, w, h);
					};
					Promise.resolve().then(async () => {
						bmp = await makeBitmapFromCurrentFile();
						done();
					});
					// Very small spin-wait (3 frames) to let the microtask finish in practice
					// (Firefox/Chromium both schedule the promise resolution quickly)
					const end = performance.now();
				} else if (srcBitmap) {
					ctx.drawImage(srcBitmap, x, y, w, h);
				} else if (srcImage) {
					ctx.drawImage(srcImage, x, y, w, h);
				}
			} catch (err) {
				log('attemptDrawTo ERROR', { compOp, err: String(err) });
			}
			// If we drew, Alpha-probe a few points
			try {
				const mid = ctx.getImageData((x + (w / 2) | 0), (y + (h / 2) | 0), 1, 1).data;
				drew = drew || (mid[3] > 0);
			} catch (err) {
				log('probe ERROR', String(err));
			}
			// Ensure the area isn’t fully transparent for visibility in HUD
			ctx.globalCompositeOperation = 'destination-over';
			ctx.fillStyle = '#00000022';
			ctx.fillRect(x, y, w, h);
			ctx.restore();
			log('attemptDrawTo', { compOp, forceRebitmap, drew });
			return drew;
		}
		/* ================================
		 BUILD / RENDER
		================================ */
		function createPuzzle() {
			const myToken = ++buildToken;
			log('createPuzzle start', { token: myToken });
			pieceGroups = [];
			puzzleSolved = false;
			const container = puzzleBoard.parentElement;
			const containerWidth = container.clientWidth | 0;
			const containerHeight = container.clientHeight | 0;
			log('container size', { containerWidth, containerHeight });
			if (containerWidth < 10 || containerHeight < 10) {
				log('container too small, reflow defer');
				requestAnimationFrame(() => { if (myToken === buildToken) createPuzzle(); });
				return;
			}
			puzzleBoard.innerHTML = '';
			assemblyArea = document.createElement('div');
			assemblyArea.id = 'assembly-area';
			puzzleBoard.appendChild(assemblyArea);
			puzzleBoard.appendChild(boardPlaceholder);
			puzzleBoard.appendChild(winMessage);
			winMessage.classList.remove('show');
			boardPlaceholder.style.display = 'none';
			const padded = buildPaddedSource(puzzleSizeX, puzzleSizeY, myToken);
			if (myToken !== buildToken) { log('stale build after padded; abort', { token: myToken }); return; }
			sliceSourceCanvas = padded.canvas;
			sliceSourceW = padded.width | 0;
			sliceSourceH = padded.height | 0;
			const paddedAspect = sliceSourceW / sliceSourceH;
			let assemblyWidth = (containerWidth * 0.5) | 0;
			let assemblyHeight = (assemblyWidth / paddedAspect) | 0;
			if (assemblyHeight > (containerHeight * 0.8)) {
				assemblyHeight = (containerHeight * 0.8) | 0;
				assemblyWidth = (assemblyHeight * paddedAspect) | 0;
			}
			const boardWidth = containerWidth;
			const boardHeight = containerHeight;
			puzzleBoard.style.width = `${boardWidth}px`;
			puzzleBoard.style.height = `${boardHeight}px`;
			pieceWidth = Math.max(1, (assemblyWidth / puzzleSizeX) | 0);
			pieceHeight = Math.max(1, (assemblyHeight / puzzleSizeY) | 0);
			assemblyWidth = pieceWidth * puzzleSizeX;
			assemblyHeight = pieceHeight * puzzleSizeY;
			const assemblyX = ((boardWidth - assemblyWidth) / 2) | 0;
			const assemblyY = ((boardHeight - assemblyHeight) / 2) | 0;
			assemblyArea.style.width = `${assemblyWidth}px`;
			assemblyArea.style.height = `${assemblyHeight}px`;
			assemblyArea.style.left = `${assemblyX}px`;
			assemblyArea.style.top = `${assemblyY}px`;
			log('layout', { assemblyWidth, assemblyHeight, pieceWidth, pieceHeight });
			const sw = (sliceSourceW / puzzleSizeX) | 0;
			const sh = (sliceSourceH / puzzleSizeY) | 0;
			log('source-slice', { sw, sh });
			for (let y = 0; y < puzzleSizeY; y++) {
				for (let x = 0; x < puzzleSizeX; x++) {
					if (myToken !== buildToken) { log('stale build mid-loop; abort', { token: myToken }); return; }
					const piece = createPieceCanvas(x, y, sw, sh, myToken);
					const group = createPieceGroup(piece);
					placeGroupRandomly(group, boardWidth, boardHeight, { x: assemblyX, y: assemblyY, width: assemblyWidth, height: assemblyHeight });
					puzzleBoard.appendChild(group.element);
					pieceGroups.push(group);
				}
			}
			log('createPuzzle done', { token: myToken, pieces: pieceGroups.length });
		}
		function createPieceCanvas(x, y, sw, sh, token) {
			const piece = document.createElement('canvas');
			piece.className = 'puzzle-piece';
			piece.width = Math.max(1, pieceWidth);
			piece.height = Math.max(1, pieceHeight);
			piece.style.width = `${pieceWidth}px`;
			piece.style.height = `${pieceHeight}px`;
			piece.style.left = '0px';
			piece.style.top = '0px';
			piece.dataset.correctX = x;
			piece.dataset.correctY = y;
			const ctx = piece.getContext('2d');
			// tile canary
			ctx.fillStyle = '#00000011';
			ctx.fillRect(0, 0, piece.width, piece.height);
			const sx = (x * sw) | 0;
			const sy = (y * sh) | 0;
			try {
				ctx.drawImage(
					sliceSourceCanvas,
					sx, sy, sw, sh,
					0, 0, piece.width, piece.height
				);
			} catch (err) {
				log('ERROR drawImage piece', { token, x, y, err: String(err) });
			}
			// Debug: quick alpha probe
			if (DEBUG) {
				try {
					const data = ctx.getImageData(0, 0, Math.min(8, piece.width), Math.min(8, piece.height)).data;
					let aSum = 0; for (let i = 3; i < data.length; i += 4) aSum += data[i];
					log('piece-sample', { token, x, y, aSum });
				} catch (err) {
					log('piece-sample ERROR', String(err));
				}
			}
			return piece;
		}
		/* ================================
		 DRAGGING / MERGE (unchanged)
		================================ */
		function createPieceGroup(initialPiece) {
			const groupElement = document.createElement('div');
			groupElement.className = 'puzzle-group';
			groupElement.appendChild(initialPiece);
			const group = {
				element: groupElement,
				pieces: [initialPiece],
				minX: parseInt(initialPiece.dataset.correctX),
				minY: parseInt(initialPiece.dataset.correctY),
				widthInPieces: 1,
				heightInPieces: 1,
			};
			addDragListeners(group);
			return group;
		}
		function placeGroupRandomly(group, boardW, boardH, assemblyRect) {
			const pw = pieceWidth, ph = pieceHeight;
			let x, y;
			const placementArea = Math.floor(Math.random() * 4);
			const safeW = Math.max(0, boardW - pw);
			const safeH = Math.max(0, boardH - ph);
			switch (placementArea) {
				case 0: x = Math.random() * safeW; y = Math.max(0, Math.random() * Math.max(0, assemblyRect.y - ph)); break;
				case 1: x = Math.random() * safeW; y = (assemblyRect.y + assemblyRect.height) + Math.random() * Math.max(0, boardH - (assemblyRect.y + assemblyRect.height) - ph); break;
				case 2: x = Math.max(0, Math.random() * Math.max(0, assemblyRect.x - pw)); y = Math.random() * safeH; break;
				default: x = (assemblyRect.x + assemblyRect.width) + Math.random() * Math.max(0, boardW - (assemblyRect.x + assemblyRect.width) - pw); y = Math.random() * safeH; break;
			}
			group.element.style.left = `${Math.max(0, x || 0)}px`;
			group.element.style.top = `${Math.max(0, y || 0)}px`;
		}
		function addDragListeners(group) {
			let offsetX, offsetY;
			const groupElement = group.element;
			function onDragStart(e) {
				if (puzzleSolved) return;
				e.preventDefault();
				groupElement.classList.add('dragging');
				puzzleBoard.appendChild(groupElement);
				const t = e.touches?.[0] || e;
				const clientX = t.clientX, clientY = t.clientY;
				const rect = groupElement.getBoundingClientRect();
				offsetX = clientX - rect.left; offsetY = clientY - rect.top;
				document.addEventListener('mousemove', onDragMove);
				document.addEventListener('mouseup', onDragEnd);
				document.addEventListener('touchmove', onDragMove, { passive: false });
				document.addEventListener('touchend', onDragEnd);
			}
			function onDragMove(e) {
				e.preventDefault();
				const t = e.touches?.[0] || e;
				const clientX = t.clientX, clientY = t.clientY;
				const boardRect = puzzleBoard.getBoundingClientRect();
				let newX = clientX - boardRect.left - offsetX;
				let newY = clientY - boardRect.top - offsetY;
				const groupWidth = group.widthInPieces * pieceWidth;
				const groupHeight = group.heightInPieces * pieceHeight;
				const maxX = puzzleBoard.clientWidth - groupWidth;
				const maxY = puzzleBoard.clientHeight - groupHeight;
				newX = Math.max(0, Math.min(newX, maxX));
				newY = Math.max(0, Math.min(newY, maxY));
				groupElement.style.left = `${newX | 0}px`;
				groupElement.style.top = `${newY | 0}px`;
			}
			function onDragEnd() {
				groupElement.classList.remove('dragging');
				document.removeEventListener('mousemove', onDragMove);
				document.removeEventListener('mouseup', onDragEnd);
				document.removeEventListener('touchmove', onDragMove);
				document.removeEventListener('touchend', onDragEnd);
				checkForMultiSnap(group);
			}
			groupElement.addEventListener('mousedown', onDragStart);
			groupElement.addEventListener('touchstart', onDragStart, { passive: true });
		}
		function checkForMultiSnap(draggedGroup) {
			let groupToCheck = draggedGroup;
			let madeAMerge = true;
			while (madeAMerge) {
				madeAMerge = false;
				for (let i = pieceGroups.length - 1; i >= 0; i--) {
					const stationaryGroup = pieceGroups[i];
					if (stationaryGroup === groupToCheck) continue;
					const snapResult = findAndPerformSnap(groupToCheck, stationaryGroup);
					if (snapResult) { groupToCheck = stationaryGroup; madeAMerge = true; break; }
				}
			}
		}
		function findAndPerformSnap(draggedGroup, stationaryGroup) {
			for (const draggedPiece of draggedGroup.pieces) {
				for (const stationaryPiece of stationaryGroup.pieces) {
					const dir = checkAdjacency(draggedPiece, stationaryPiece);
					if (dir) { alignAndMerge(draggedGroup, stationaryGroup, draggedPiece, stationaryPiece, dir); return true; }
				}
			}
			return false;
		}
		function checkAdjacency(dp, sp) {
			const dpX = parseInt(dp.dataset.correctX), dpY = parseInt(dp.dataset.correctY);
			const spX = parseInt(sp.dataset.correctX), spY = parseInt(sp.dataset.correctY);
			const dr = dp.getBoundingClientRect(), sr = sp.getBoundingClientRect();
			if (dpX === spX + 1 && dpY === spY && Math.abs(dr.left - sr.right) < SNAP_TOLERANCE && Math.abs(dr.top - sr.top) < SNAP_TOLERANCE) return 'right';
			if (dpX === spX - 1 && dpY === spY && Math.abs(dr.right - sr.left) < SNAP_TOLERANCE && Math.abs(dr.top - sr.top) < SNAP_TOLERANCE) return 'left';
			if (dpY === spY + 1 && dpX === spX && Math.abs(dr.top - sr.bottom) < SNAP_TOLERANCE && Math.abs(dr.left - sr.left) < SNAP_TOLERANCE) return 'down';
			if (dpY === spY - 1 && dpX === spX && Math.abs(dr.bottom - sr.top) < SNAP_TOLERANCE && Math.abs(dr.left - sr.left) < SNAP_TOLERANCE) return 'up';
			return null;
		}
		function alignAndMerge(dg, sg, dp, sp, direction) {
			const sgPos = { left: sg.element.offsetLeft, top: sg.element.offsetTop };
			const spOff = { left: parseFloat(sp.style.left), top: parseFloat(sp.style.top) };
			const dpOff = { left: parseFloat(dp.style.left), top: parseFloat(dp.style.top) };
			let targetLeft, targetTop;
			switch (direction) {
				case 'right': targetLeft = sgPos.left + spOff.left + pieceWidth - dpOff.left; targetTop = sgPos.top + spOff.top - dpOff.top; break;
				case 'left': targetLeft = sgPos.left + spOff.left - pieceWidth - dpOff.left; targetTop = sgPos.top + spOff.top - dpOff.top; break;
				case 'down': targetLeft = sgPos.left + spOff.left - dpOff.left; targetTop = sgPos.top + spOff.top + pieceHeight - dpOff.top; break;
				case 'up': targetLeft = sgPos.left + spOff.left - dpOff.left; targetTop = sgPos.top + spOff.top - pieceHeight - dpOff.top; break;
			}
			dg.element.style.left = `${targetLeft | 0}px`;
			dg.element.style.top = `${targetTop | 0}px`;
			mergeGroups(dg, sg);
		}
		function mergeGroups(dg, sg) {
			const dEl = dg.element, sEl = sg.element;
			const offsetX = dEl.offsetLeft - sEl.offsetLeft;
			const offsetY = dEl.offsetTop - sEl.offsetTop;
			while (dEl.firstChild) {
				const piece = dEl.firstChild;
				piece.style.left = `${(parseFloat(piece.style.left) + offsetX) | 0}px`;
				piece.style.top = `${(parseFloat(piece.style.top) + offsetY) | 0}px`;
				sEl.appendChild(piece);
				sg.pieces.push(piece);
			}
			let minX = Infinity, minY = Infinity;
			for (const p of sg.pieces) { const l = parseFloat(p.style.left), t = parseFloat(p.style.top); if (l < minX) minX = l; if (t < minY) minY = t; }
			if (minX || minY) {
				sEl.style.left = `${(sEl.offsetLeft + minX) | 0}px`;
				sEl.style.top = `${(sEl.offsetTop + minY) | 0}px`;
				for (const p of sg.pieces) {
					p.style.left = `${(parseFloat(p.style.left) - minX) | 0}px`;
					p.style.top = `${(parseFloat(p.style.top) - minY) | 0}px`;
				}
			}
			puzzleBoard.removeChild(dEl);
			pieceGroups = pieceGroups.filter(g => g !== dg);
			sg.minX = Math.min(sg.minX, dg.minX);
			sg.minY = Math.min(sg.minY, dg.minY);
			let maxX = sg.minX, maxY = sg.minY;
			for (const p of sg.pieces) { const px = parseInt(p.dataset.correctX), py = parseInt(p.dataset.correctY); if (px > maxX) maxX = px; if (py > maxY) maxY = py; }
			sg.widthInPieces = maxX - sg.minX + 1;
			sg.heightInPieces = maxY - sg.minY + 1;
			checkWinCondition();
		}
		function checkWinCondition() {
			if (pieceGroups.length === 1 && pieceGroups[0].pieces.length === puzzleSizeX * puzzleSizeY) {
				const finalGroup = pieceGroups[0];
				const finalX = assemblyArea.offsetLeft - (finalGroup.minX * pieceWidth);
				const finalY = assemblyArea.offsetTop - (finalGroup.minY * pieceHeight);
				finalGroup.element.style.transition = 'left .5s, top .5s, filter .5s';
				finalGroup.element.style.left = `${finalX}px`;
				finalGroup.element.style.top = `${finalY}px`;
				finalGroup.element.style.cursor = 'default';
				finalGroup.element.style.zIndex = '5';
				finalGroup.element.style.filter = 'none';
				puzzleSolved = true;
				winMessage.classList.add('show');
			}
		}
		/* ================================
		 DEBUG: Canvas self-test (proves canvas draws)
		================================ */
		function selfTestCanvas() {
			const w = 256, h = 256;
			const c = debugPaddedCanvas;
			c.width = w; c.height = h;
			const ctx = c.getContext('2d');
			// gradient
			const g = ctx.createLinearGradient(0, 0, w, h);
			g.addColorStop(0, '#0ea5e9'); g.addColorStop(1, '#22c55e');
			ctx.fillStyle = g; ctx.fillRect(0, 0, w, h);
			// dot
			ctx.fillStyle = '#ffffff'; ctx.fillRect(124, 124, 8, 8);
			// check
			const dot = ctx.getImageData(128, 128, 1, 1).data;
			log('SELF-TEST pixel (should be white, a>0):', Array.from(dot));
		}
		// Button for raw-draw test.
		btnRawDraw = document.createElement('button');
		btnRawDraw.textContent = 'Raw draw src → HUD';
		btnRawDraw.onclick = () => {
			const c = debugPaddedCanvas;
			const w = (srcBitmap ? srcBitmap.width : (srcImage?.naturalWidth || 256));
			const h = (srcBitmap ? srcBitmap.height : (srcImage?.naturalHeight || 256));
			c.width = w; c.height = h;
			const ctx = c.getContext('2d');
			ctx.clearRect(0, 0, w, h);
			ctx.fillStyle = '#ff00ff88';
			ctx.fillRect(0, 0, w, h);
			try {
				if (srcBitmap) ctx.drawImage(srcBitmap, 0, 0);
				else if (srcImage) ctx.drawImage(srcImage, 0, 0);
			} catch (e) {
				log('Raw draw ERROR', String(e));
			}
			try {
				const p = ctx.getImageData((w / 2) | 0, (h / 2) | 0, 1, 1).data;
				log('Raw draw probe (center)', Array.from(p));
			} catch (e) {
				log('Raw draw probe ERROR', String(e));
			}
		};
		document.getElementById('debug-cta').appendChild(btnRawDraw);
	</script>
</body>
</html>