<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0" />
	<title>Custom Jigsaw Puzzle</title>

	<!-- Enable class-based dark mode for Tailwind -->
	<script src="https://cdn.tailwindcss.com"></script>
	<script>
		window.tailwind = window.tailwind || {};
		tailwind.config = { darkMode: 'class' };
	</script>

	<script src="https://unpkg.com/gifler@0.1.0/gifler.min.js"></script>
	<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
	<style>
		html, body { height: 100%; }
		body {
			font-family: 'Inter', sans-serif;
			touch-action: none;
			overflow: hidden
		}

		.puzzle-group {
			position: absolute;
			cursor: grab;
			z-index: 10;
			/* Note: we must use box-shadow, not filter: drop-shadow, because that causes issues on Firefox. (Containers with CSS filters cause descendant canvas elements to render wrong.) */
			box-shadow: 0 2px 4px rgba(0, 0, 0, .25);
			transition: box-shadow .1s, z-index 0s .1s
		}
		.puzzle-group.dragging {
			cursor: grabbing;
			z-index: 20;
			box-shadow: 0 10px 15px rgba(0, 0, 0, .25);
		}

		.puzzle-piece {
			position: absolute;
			border: none;
			transition: transform .1s;
			background: rgba(0, 0, 0, 0.02)
		}
		.puzzle-group.dragging .puzzle-piece { transform: scale(1.025) }

		#puzzle-board {
			background: #f0f4f8;
			position: relative;
			overflow: hidden;
			border-radius: .5rem;
			box-shadow: inset 0 2px 4px rgba(0, 0, 0, .06)
		}
		/* Dark theme tweaks */
		:root.dark #puzzle-board { background: #0b1220; box-shadow: inset 0 2px 6px rgba(0,0,0,.35) }
		:root.dark .control-panel { background: #0f172a; box-shadow: 0 10px 15px -3px rgba(0,0,0,.5), 0 4px 6px -2px rgba(0,0,0,.4) }
		:root.dark #assembly-area { border-color: #334155 }
		:root.dark .win-message-content { background: #166534 }

		/* --- Merge feedback (sound is JS; this is the visual) --- */
		/* A temporary overlay sized to the merged group's bounding box. */
		.merge-highlight {
			position: absolute;
			left: 0; top: 0;
			pointer-events: none;
			border-radius: .375rem;
			outline: 2px solid rgba(99,102,241,0); /* indigo-ish outline */
			z-index: 1; /* above pieces, inside group */
		}
		.merge-highlight.run {
			animation: mhFlash .35s ease-out forwards;
		}
		@keyframes mhFlash {
			0%   { outline-color: rgba(99,102,241,.95); box-shadow: 0 0 0 4px rgba(99,102,241,.18) }
			70%  { outline-color: rgba(99,102,241,.35); box-shadow: 0 0 0 8px rgba(99,102,241,.12) }
			100% { outline-color: rgba(99,102,241,0);   box-shadow: none }
		}

		#assembly-area {
			position: absolute;
			border: 2px dashed #cbd5e1;
			box-sizing: border-box;
			pointer-events: none
		}

		.control-panel {
			background: #fff;
			padding: 0.5rem;
			border-radius: .75rem;
			box-shadow: 0 10px 15px -3px rgba(0, 0, 0, .1), 0 4px 6px -2px rgba(0, 0, 0, .05)
		}

		.corner-notes {
			font-size: x-small !important;
		}

		#win-message {
			position: absolute;
			bottom: 0;
			left: 0;
			width: 100%;
			display: flex;
			justify-content: center;
			background: linear-gradient(to top, rgba(0, 0, 0, .6), transparent);
			padding: 2rem 1rem;
			box-sizing: border-box;
			opacity: 0;
			transform: translateY(100%);
			pointer-events: none;
			transition: opacity .5s, transform .5s;
			z-index: 9000;
		}
		#win-message.show { opacity: 1; transform: translateY(0); pointer-events: auto }

		.win-message-content {
			text-align: center;
			padding: 1.5rem 3rem;
			background: #2f855a;
			border-radius: .75rem;
			box-shadow: 0 10px 25px rgba(0, 0, 0, .3)
		}
		.win-message-content h2 { font-size: 3rem; font-weight: 700; color: #fff }

		/* DEBUG HUD */
		#debug-hud {
			position: fixed;
			right: 12px;
			bottom: 12px;
			background: rgba(0, 0, 0, .88);
			color: #e2e8f0;
			border: 1px solid rgba(255, 255, 255, .15);
			border-radius: .75rem;
			padding: .75rem;
			max-width: 46vw;
			max-height: 64vh;
			overflow: auto;
			z-index: 9999;
			display: none
		}
		#debug-hud h3 { font-weight: 700; margin-bottom: .25rem }
		#debug-hud pre {
			font-family: ui-monospace, SFMono-Regular, Menlo, monospace;
			font-size: 12px; line-height: 1.3; white-space: pre-wrap; word-break: break-word
		}
		#debug-row { display: flex; gap: .75rem; align-items: flex-start; margin-top: .5rem }
		#debug-padded { background: repeating-conic-gradient(#111 0% 25%, #222 0% 50%) 50%/20px 20px; outline: 1px solid #475569; max-width: 24vw; height: auto }
		#debug-controls { display: flex; gap: .5rem; align-items: center; margin: .25rem 0 .5rem }
	</style>
</head>

<body class="bg-slate-100 dark:bg-slate-900 text-slate-800 dark:text-slate-200 flex flex-col items-center justify-center h-screen p-4">
	<!-- expand to full width (remove max-w constraint) -->
	<div class="w-full mx-auto flex flex-col h-full">
		<!-- Header with helper text to the right -->
		<header class="mb-3 shrink-0">
			<div class="flex flex-wrap items-center justify-between gap-2">
				<h1 class="text-4xl font-bold text-slate-700 dark:text-slate-200">Custom jigsaw puzzle</h1>
				<span class="corner-notes text-slate-800 dark:text-slate-200 text-sm sm:text-base">
					<p>Runs entirely in your browser - your images are not sent to any other computer.</p>
					<p>Supports animated GIFs, WEBM, and MP4!</p>
				</span>
			</div>
		</header>

		<div class="control-panel mb-4 flex flex-col sm:flex-row items-center justify-center gap-4 shrink-0 dark:border dark:border-slate-700">
			<div class="flex items-center gap-3">
				<label for="image-loader"
					class="cursor-pointer bg-blue-500 text-white font-bold py-2 px-4 rounded-md hover:bg-blue-600 transition-colors">
					Select Image
				</label>
				<input type="file" id="image-loader" class="hidden" accept="image/png, image/jpeg, image/gif, video/webm, video/mp4">
			</div>

			<div class="flex items-center gap-3">
				<label for="difficulty-select" class="font-medium">Difficulty:</label>
				<select id="difficulty-select" class="cursor-pointer border rounded px-2 py-1 dark:bg-slate-800 dark:border-slate-700"></select>
			</div>

			<button id="scramble-btn"
				class="bg-green-500 text-white font-bold py-2 px-4 rounded-md hover:bg-green-600 transition-colors disabled:bg-gray-400 disabled:cursor-not-allowed"
				disabled>Scramble</button>

			<!-- Spacer pushes toggles to right on wide screens -->
			<div class="hidden sm:block sm:ml-auto"></div>

			<!-- Dark mode toggle -->
			<label class="flex items-center gap-2 text-sm select-none">
				<input id="dark-mode-toggle" type="checkbox" class="cursor-pointer">
				<span class="font-medium">Dark</span>
			</label>

			<!-- UI Debug toggle -->
			<label class="flex items-center gap-2 text-sm select-none">
				<input id="ui-debug-toggle" type="checkbox" class="cursor-pointer">
				<span class="font-medium">Debug</span>
			</label>
		</div>

		<!-- Let the board take all remaining space -->
		<main id="puzzle-board-container"
			class="flex-grow w-full flex items-center justify-center relative bg-white dark:bg-slate-800 rounded-lg shadow-md overflow-hidden">
			<div id="puzzle-board" class="w-full h-full">
				<p id="board-placeholder" class="text-slate-600 dark:text-slate-300 absolute inset-0 flex items-center justify-center">
					Use the button in the top-left to select an image.
				</p>
				<div id="win-message">
					<div class="win-message-content">
						<h2>Puzzle solved!</h2>
					</div>
				</div>
			</div>
		</main>
	</div>

	<!-- DEBUG HUD -->
	<div id="debug-hud">
		<h3>Debug</h3>
		<div id="debug-controls">
			<label class="text-xs opacity-80"><input id="toggle-bitmap" type="checkbox"> use ImageBitmap</label>
			<label class="text-xs opacity-80"><input id="toggle-copy" type="checkbox" checked> composite=copy</label>
		</div>
		<pre id="debug-env"></pre>
		<pre id="debug-log"></pre>
		<div id="debug-row">
			<canvas id="debug-padded"></canvas>
			<pre id="debug-metrics"></pre>
		</div>
	</div>

	<script>
		/* ================================
		App State & Feature Flags
		================================ */

		let DEBUG_ENABLED = false;            // UI toggle
		let USE_BITMAP = false;               // toggled in HUD
		let USE_COMPOSITE_COPY = true;        // toggled in HUD

		const imageLoader = document.getElementById('image-loader');
		const difficultySelect = document.getElementById('difficulty-select');
		const scrambleBtn = document.getElementById('scramble-btn');
		scrambleBtn.disabled = true;
		const puzzleBoard = document.getElementById('puzzle-board');
		const boardPlaceholder = document.getElementById('board-placeholder');
		const winMessage = document.getElementById('win-message');
		const uiDebugToggle = document.getElementById('ui-debug-toggle');
		const darkToggle = document.getElementById('dark-mode-toggle');
		uiDebugToggle.checked = false;

		// Initialize dark mode from system or localStorage
		(function initTheme() {
			const saved = localStorage.getItem('jigsaw-theme');
			const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
			const shouldDark = saved ? (saved === 'dark') : prefersDark;
			document.documentElement.classList.toggle('dark', shouldDark);
			darkToggle.checked = shouldDark;
		})();

		darkToggle.addEventListener('change', () => {
			const enabled = darkToggle.checked;
			document.documentElement.classList.toggle('dark', enabled);
			localStorage.setItem('jigsaw-theme', enabled ? 'dark' : 'light');
		});

		// Debug HUD elements (shown only when debug enabled)
		const debugHud = document.getElementById('debug-hud');
		const debugEnv = document.getElementById('debug-env');
		const debugLogEl = document.getElementById('debug-log');
		const debugPaddedCanvas = document.getElementById('debug-padded');
		const debugMetricsEl = document.getElementById('debug-metrics');
		const toggleBitmap = document.getElementById('toggle-bitmap');
		const toggleCopy = document.getElementById('toggle-copy');

		// Puzzle layout state
		let assemblyArea = null;
		let pieceGroups = [];
		let basePuzzleSize = 4;
		let puzzleSizeX = 4;
		let puzzleSizeY = 4;
		let pieceWidth = 0;
		let pieceHeight = 0;
		let puzzleSolved = false;
		let buildToken = 0;

		const SNAP_TOLERANCE = 30;

		/* Click SFX (plays on merge). We clone for overlapping plays. */
		const CLICK_VOLUME = 0.15;
		const clickAudio = new Audio('./assets/click.mp3');
		clickAudio.preload = 'auto';
		clickAudio.volume = CLICK_VOLUME;

		function playClick() {
			try {
				// Clone to allow rapid consecutive merges to overlap.
				const a = clickAudio.cloneNode();
				a.volume = CLICK_VOLUME;
				// Play is user-gesture unlocked because it happens after a drag.
				a.play().catch(() => {});
				setTimeout(() => { try { a.remove(); } catch {} }, 4000);
			} catch {}
		}

		/* Visual overlay that sweeps diagonally across the newly merged group. */
		function runMergeHighlight(group) {
			// Remove any previous highlight still hanging around (e.g., mid-animation)
			try {
				group.element.querySelectorAll('.merge-highlight').forEach(n => n.remove());
			} catch {}
			// Size to group's occupied grid area
			const w = Math.max(1, group.widthInPieces * pieceWidth);
			const h = Math.max(1, group.heightInPieces * pieceHeight);
			const overlay = document.createElement('div');
			overlay.className = 'merge-highlight';
			overlay.style.width = `${w}px`;
			overlay.style.height = `${h}px`;
			group.element.appendChild(overlay);
			// kick off animations
			// (force reflow so class change triggers keyframes in all browsers)
			void overlay.offsetHeight;
			overlay.classList.add('run');
			overlay.addEventListener('animationend', () => {
				try { overlay.remove(); } catch {}
			}, { once: true });
		}

		// Source decoding / rendering state
		let srcFile = null;
		let frameSource = null;         // implements IFrameSource (see below)
		let sliceSourceCanvas = null;   // padded frame canvas (current frame)
		let sliceSourceW = 0;
		let sliceSourceH = 0;
		let imageAspectRatio = 1;
		let paddedReuseCanvas = null; // reused for slicing

		// Animation loop (for future GIF support)
		let animRAF = null;
		let animRunning = false;

		function clamp(val, min, max) { return Math.max(min, Math.min(val, max)); }

		/* ================================
		Building difficulty options around current image aspect.
		================================ */
		function buildDifficultyOptions() {
			if (!frameSource?.ready) {
				difficultySelect.innerHTML = '';
				return;
			}

			const aspect = imageAspectRatio; // w/h
			const options = [];

			// For k=2..12, compute gridX/gridY so pieces are ~square
			for (let k = 2; k <= 12; k++) {
				// Choose the short side = k, compute the long side ≈ k*aspect (rounded)
				let gx, gy;
				if (aspect >= 1) {
					// wide image
					gx = Math.max(3, Math.round(k * aspect));
					gy = k;
				} else {
					// tall image
					gx = k;
					gy = Math.max(3, Math.round(k / aspect));
				}
				options.push([gx, gy]);
			}

			// Deduplicate (e.g., many k may map to the same pair), and cap sizes
			const key = (p) => `${p[0]}x${p[1]}`;
			const seen = new Set();
			const deduped = [];
			for (const p of options) {
				const k = key(p);
				if (!seen.has(k) && p[0] <= 100 && p[1] <= 100) { // basic sanity caps
					seen.add(k);
					deduped.push(p);
				}
			}

			// Sort by approx number of pieces (ascending)
			deduped.sort((a, b) => (a[0] * a[1]) - (b[0] * b[1]));

			// Fill the <select>, keep the previously-selected value if possible
			const prev = `${puzzleSizeX}x${puzzleSizeY}`;
			difficultySelect.innerHTML = deduped.map(([gx, gy]) =>
				`<option value="${gx}x${gy}">${gx}×${gy}</option>`).join('');

			const first = deduped[0];
			const fallbackVal = `${first[0]}x${first[1]}`;

			const toSelect = difficultySelect.querySelector(`option[value="${prev}"]`)
				? prev : fallbackVal;

			difficultySelect.value = toSelect;

			// Apply to state
			const [gx, gy] = toSelect.split('x').map(Number);
			puzzleSizeX = gx;
			puzzleSizeY = gy;
		}

		/* ================================
		Debug helpers
		================================ */
		function ts() {
			return new Date().toISOString().slice(11, 23);
		}
		function log(...args) {
			if (!DEBUG_ENABLED) return;
			const line = `[${ts()}] ${args.map(a => (
				typeof a === 'object' ? JSON.stringify(a) : String(a)
			)).join(' ')}`;
			console.log(...args);
			if (debugLogEl) {
				debugLogEl.textContent += line + '\n';
				debugLogEl.scrollTop = debugLogEl.scrollHeight;
			}
		}
		function clearLog() {
			if (DEBUG_ENABLED && debugLogEl) debugLogEl.textContent = '';
		}
		function setDebugUI(visible) {
			DEBUG_ENABLED = visible;
			debugHud.style.display = visible ? 'block' : 'none';
			if (visible) {
				toggleBitmap.checked = USE_BITMAP;
				toggleCopy.checked = USE_COMPOSITE_COPY;

				debugEnv.textContent =
`UA: ${navigator.userAgent}
createImageBitmap: ${!!window.createImageBitmap}
colorSpace: ${'colorSpace' in CanvasRenderingContext2D.prototype ? 'yes' : 'no'}
getImageData: ${typeof CanvasRenderingContext2D.prototype.getImageData}
`;
			}
		}

		/* ================================
		UI Events
		================================ */
		uiDebugToggle.addEventListener('change', () => {
			setDebugUI(uiDebugToggle.checked);
		});

		imageLoader.addEventListener('change', e => {
			const file = e.target.files?.[0];
			if (!file) return;
			srcFile = file;
			loadFromFile(file);
		});

		difficultySelect.addEventListener('change', () => {
			const [gx, gy] = difficultySelect.value.split('x').map(Number);
			puzzleSizeX = gx;
			puzzleSizeY = gy;
			log('difficulty.change → rebuild');
			createPuzzle();
		});

		scrambleBtn.addEventListener('click', () => {
			if (frameSource?.ready) createPuzzle();
		});

		let resizeRAF = null;
		window.addEventListener('resize', () => {
			if (!frameSource?.ready) return;
			cancelAnimationFrame(resizeRAF);
			resizeRAF = requestAnimationFrame(() => {
				log('window.resize → relayout (preserve groups)');
				buildDifficultyOptions();           // keep dropdown labels up to date
				relayoutPuzzlePreserveGroups();     // <— new function (see below)
			});
		});

		/* ================================
		Debug HUD event wiring
		================================ */
		toggleBitmap.addEventListener('change', () => {
			USE_BITMAP = toggleBitmap.checked;
			log('TOGGLE USE_BITMAP', USE_BITMAP);
			if (srcFile) loadFromFile(srcFile);
		});
		toggleCopy.addEventListener('change', () => {
			USE_COMPOSITE_COPY = toggleCopy.checked;
			log('TOGGLE composite=copy', USE_COMPOSITE_COPY);
			if (frameSource?.ready) createPuzzle();
		});

		/* ================================
		IFrameSource (prepping for GIFs)
		--------------------------------
		StaticImageSource: wraps a single decoded image or ImageBitmap.
		GifFrameSource: decodes frames & exposes a synced canvas.
		VideoFrameSource: for WEBM and MP4
		================================ */

		function fileToDataURL(file) {
			return new Promise((res, rej) => {
				const r = new FileReader();
				r.onerror = () => rej(r.error);
				r.onload = () => res(r.result);
				r.readAsDataURL(file);
			});
		}
		function loadHTMLImage(src) {
			return new Promise((res, rej) => {
				const img = new Image();
				img.decoding = 'async';
				img.onload = async () => {
					try { if (img.decode) await img.decode(); } catch { }
					res(img);
				};
				img.onerror = rej;
				img.src = src;
			});
		}

		class StaticImageSource {
			constructor(width, height, source) {
				this.ready = true;
				this.animated = false;
				this.width = width;
				this.height = height;
				this._element = source;
				this._canvas = document.createElement('canvas');
				this._canvas.width = width;
				this._canvas.height = height;
				const ctx = this._canvas.getContext('2d', { willReadFrequently: true });
				ctx.drawImage(source, 0, 0, width, height);
			}
			currentFrameCanvas() {
				return this._canvas;
			}
			sourceElement() {
				return this._element;
			}
			start() {}
			stop() {}
		}

		class GifFrameSource {
			constructor(file) {
				this.ready = false;
				this.animated = true;
				this.width = 1;
				this.height = 1;

				this._canvas = document.createElement('canvas');
				this._ctx = this._canvas.getContext('2d', { willReadFrequently: true });
				this._animator = null;
				this._onFrame = () => { };
				this._onReady = null;
				this._objectURL = URL.createObjectURL(file);

				// For disposal handling
				this._prevRect = null;           // {x,y,w,h}
				this._prevDisposal = 0;          // 0/1/2/3
				this._snapshot = null;           // ImageData for dispose=3

				gifler(this._objectURL).get((animator) => {
					this._animator = animator;

					// Let gifler size our canvas to GIF logical screen
					animator.animateInCanvas(this._canvas, /* setDimensions */ true);
					this.width = this._canvas.width;
					this.height = this._canvas.height;

					// We manage compositing ourselves for cross-browser correctness.
					animator.onDrawFrame = (_ctxFromGifler, frame) => {
						const x = ('x' in frame) ? frame.x : (frame.dims?.left || 0);
						const y = ('y' in frame) ? frame.y : (frame.dims?.top || 0);
						const w = ('width' in frame) ? frame.width : (frame.dims?.width || frame.buffer?.width || 0);
						const h = ('height' in frame) ? frame.height : (frame.dims?.height || frame.buffer?.height || 0);
						const disposal = (typeof frame.disposalType === 'number') ? frame.disposalType : 0;

						// Apply disposal of the *previous* frame
						if (this._prevRect) {
							if (this._prevDisposal === 2) {
								// Restore to background: clear the previous rect
								this._ctx.clearRect(this._prevRect.x, this._prevRect.y, this._prevRect.w, this._prevRect.h);
							} else if (this._prevDisposal === 3 && this._snapshot) {
								// Restore to previous: put back the snapshot
								try {
									this._ctx.putImageData(this._snapshot, 0, 0);
								} catch { }
							}
						}

						// If the upcoming frame asks for "restore to previous", take a snapshot now.
						// (Most encoders use this sparingly; snapshot once per frame is OK for our sizes.)
						this._snapshot = null;
						if (disposal === 3) {
							try {
								this._snapshot = this._ctx.getImageData(0, 0, this.width, this.height);
							} catch {
								this._snapshot = null;
							}
						}

						// Draw the current patch
						this._ctx.globalCompositeOperation = 'source-over';
						try {
							this._ctx.drawImage(frame.buffer, x, y);
						} catch (e) {
							// Extremely old Firefox builds had stricter types for drawImage;
							// no-op here to avoid crashing the loop.
						}

						// Record disposal info for next tick
						this._prevRect = { x, y, w, h };
						this._prevDisposal = disposal | 0;

						// Notify listeners
						this._onFrame();
					};

					this.ready = true;
					if (this._onReady) this._onReady();
				});
			}

			currentFrameCanvas() { return this._canvas; }
			sourceElement() { return this._canvas; }

			onReady(cb) { this._onReady = cb; if (this.ready) cb(); }
			onFrame(cb) { this._onFrame = cb || (() => { }); }

			start() { if (this._animator) this._animator.start(); }
			stop() { if (this._animator) this._animator.stop(); }

			destroy() {
				try { this.stop(); } catch { }
				this._snapshot = null;
				if (this._objectURL) URL.revokeObjectURL(this._objectURL);
			}
		}

		class VideoFrameSource {
			constructor(file) {
				this.ready = false;
				this.animated = true;
				this.width = 1;
				this.height = 1;

				this._canvas = document.createElement('canvas');
				this._ctx = this._canvas.getContext('2d', { willReadFrequently: true });
				this._onFrame = () => {};
				this._onReady = null;

				this._objectURL = URL.createObjectURL(file);
				this._video = document.createElement('video');
				this._video.src = this._objectURL;
				this._video.loop = true;
				this._video.muted = true;
				this._video.playsInline = true;
				this._video.preload = 'auto';

				this._rVFCToken = null;
				this._playing = false;

				this._video.addEventListener('loadedmetadata', () => {
				this.width  = Math.max(1, this._video.videoWidth | 0);
				this.height = Math.max(1, this._video.videoHeight | 0);
				this._canvas.width = this.width;
				this._canvas.height = this.height;

				const fireReady = () => {
					if (this.ready) return;
					// draw once so the canvas is non-empty
					this._drawCurrentFrame();
					this.ready = true;
					if (this._onReady) this._onReady();
				};

				// Prefer exact callback for the *first* frame
				if ('requestVideoFrameCallback' in this._video) {
					this._video.requestVideoFrameCallback(() => fireReady());
				} else {
					// Fallback: first decoded frame
					const onLoadedData = () => { this._video.removeEventListener('loadeddata', onLoadedData); fireReady(); };
					this._video.addEventListener('loadeddata', onLoadedData);
				}

				// Nudge playback so a frame actually becomes available.
				// (Muted + user gesture from file input generally allows autoplay.)
				this._video.play().catch(() => {/* ok if blocked; user can hit Scramble */});
				});

			}

			currentFrameCanvas() { return this._canvas; }
			sourceElement() { return this._canvas; }

			onReady(cb) { this._onReady = cb; if (this.ready) cb(); }
			onFrame(cb) { this._onFrame = cb || (() => {}); }

			_drawCurrentFrame() {
				try {
					this._ctx.drawImage(this._video, 0, 0, this.width, this.height);
				} catch {}
				this._onFrame();
			}

			// Prefer precise sync when available
			_scheduleRVFC() {
				if (!('requestVideoFrameCallback' in this._video)) return false;
				const tick = () => {
					if (!this._playing) return;
					this._drawCurrentFrame();
					this._rVFCToken = this._video.requestVideoFrameCallback(tick);
				};
				this._rVFCToken = this._video.requestVideoFrameCallback(tick);
				return true;
			}

			start() {
				this._playing = true;
				// Start drawing frames ASAP
				if (!this._scheduleRVFC()) {
					// Fallback: draw on 'timeupdate' + a light RAF sampler
					const onTimeUpdate = () => { if (this._playing) this._drawCurrentFrame(); };
					this._video.addEventListener('timeupdate', onTimeUpdate);
					// One extra RAF every tick to catch high-FPS playback
					const rafLoop = () => {
						if (!this._playing) return;
						this._drawCurrentFrame();
						requestAnimationFrame(rafLoop);
					};
					requestAnimationFrame(rafLoop);
					this._fallbackCleanup = () => {
						this._video.removeEventListener('timeupdate', onTimeUpdate);
					};
				}
				// Try to play (user gesture from file selection usually allows this)
				this._video.play().catch(() => {/* ignored; user can click Scramble later */});
			}

			stop() {
				this._playing = false;
				try { this._video.pause(); } catch {}
				if (this._rVFCToken && 'cancelVideoFrameCallback' in this._video) {
					try { this._video.cancelVideoFrameCallback(this._rVFCToken); } catch {}
				}
				if (this._fallbackCleanup) { try { this._fallbackCleanup(); } catch {} }
				this._rVFCToken = null;
			}

			destroy() {
				this.stop();
				if (this._objectURL) URL.revokeObjectURL(this._objectURL);
				this._objectURL = null;
				this._video.src = '';
			}
		}


		/* ================================
		Load & Decode (creates a FrameSource)
		================================ */
		async function loadFromFile(file) {
			clearLog();
			stopAnimationLoop();
			try { frameSource?.destroy?.(); } catch {}

			puzzleSolved = false;
			scrambleBtn.disabled = true;
			frameSource = null;

			log('onSelectFile', { name: file.name, size: file.size, type: file.type });

			if (file.type === 'video/webm' || file.type.startsWith('video/')) {
				try {
					frameSource = new VideoFrameSource(file);
					frameSource.onReady(() => {
						imageAspectRatio = frameSource.width / frameSource.height;
						buildDifficultyOptions();
						scrambleBtn.disabled = false;

						createPuzzle(); // build initial pieces from the first video frame

						// Every time the video advances, repaint from the latest frame.
						frameSource.onFrame(() => {
							if (!animRunning || !frameSource?.animated) return;
							rebuildSliceSourceFromCurrentFrame(puzzleSizeX, puzzleSizeY);
							repaintAllPiecesFromSlice();
						});

						startAnimationLoop(); // flip animRunning=true (same as GIF path)
						frameSource.start();
					});
				} catch (err) {
					log('VIDEO DECODE ERROR', String(err));
					alert('Failed to decode video.');
					return;
				}
				return; // handled as video path
			}

			if (file.type === 'image/gif') {
				try {
					frameSource = new GifFrameSource(file);
					frameSource.onReady(() => {
						imageAspectRatio = frameSource.width / frameSource.height;
						buildDifficultyOptions();
						scrambleBtn.disabled = false;
					createPuzzle(); // builds initial pieces from frame 0

					// Every time the GIF advances, rebuild the padded source and repaint pieces.
						frameSource.onFrame(() => {
							if (!animRunning || !frameSource?.animated) return;
							rebuildSliceSourceFromCurrentFrame(puzzleSizeX, puzzleSizeY);
							repaintAllPiecesFromSlice();
						});

					startAnimationLoop(); // just flips animRunning=true and lets frame callbacks do the work
						frameSource.start();
					});
				} catch (err) {
					log('GIF DECODE ERROR', String(err));
					alert('Failed to decode GIF.');
					return;
				}
				return; // handled as GIF path
			}

			try {
				let srcBitmap = null;
				let srcImage = null;

				if (USE_BITMAP && window.createImageBitmap) {
					srcBitmap = await createImageBitmap(file, {
						imageOrientation: 'from-image',
						premultiplyAlpha: 'premultiply',
						colorSpaceConversion: 'default'
					});
					imageAspectRatio = srcBitmap.width / srcBitmap.height;
					log('createImageBitmap(file) OK', { w: srcBitmap.width, h: srcBitmap.height });
					frameSource = new StaticImageSource(srcBitmap.width, srcBitmap.height, srcBitmap);
				} else {
					const dataURL = await fileToDataURL(file);
					srcImage = await loadHTMLImage(dataURL);
					imageAspectRatio = srcImage.naturalWidth / srcImage.naturalHeight;
					log('HTMLImageElement loaded', { w: srcImage.naturalWidth, h: srcImage.naturalHeight });
					frameSource = new StaticImageSource(srcImage.naturalWidth, srcImage.naturalHeight, srcImage);
				}
			} catch (err) {
				log('DECODE ERROR', String(err));
				alert('Failed to decode image.');
				return;
			}

			buildDifficultyOptions();
			scrambleBtn.disabled = false;
			createPuzzle();
		}

		/* ================================
		Padded Source Builder
		================================ */
		function buildPaddedSource(gridX, gridY, token) {
			const srcEl = frameSource.sourceElement ? frameSource.sourceElement()
													: frameSource.currentFrameCanvas();
			const srcW = srcEl.width || srcEl.naturalWidth;
			const srcH = srcEl.height || srcEl.naturalHeight;

			const paddedW = Math.ceil(srcW / gridX) * gridX;
			const paddedH = Math.ceil(srcH / gridY) * gridY;

			const canvas = document.createElement('canvas');
			canvas.width = paddedW;
			canvas.height = paddedH;

			const ctx = canvas.getContext('2d', { willReadFrequently: true });

			// Canary magenta background for debug.
			if (DEBUG_ENABLED) {
				ctx.fillStyle = '#ff00ff88';
				ctx.fillRect(0, 0, paddedW, paddedH);
			}

			const offsetX = Math.floor((paddedW - srcW) / 2);
			const offsetY = Math.floor((paddedH - srcH) / 2);

			let drew = attemptDrawTo(ctx, srcEl, offsetX, offsetY, srcW, srcH, 'source-over');

			if (!drew && USE_COMPOSITE_COPY) {
				drew = attemptDrawTo(ctx, srcEl, offsetX, offsetY, srcW, srcH, 'copy');
			}

			// Crosshair (debug)
			if (DEBUG_ENABLED) {
				ctx.save();
				ctx.strokeStyle = '#ff0000cc';
				ctx.beginPath();
				ctx.moveTo(offsetX, offsetY - 6);
				ctx.lineTo(offsetX, offsetY + 6);
				ctx.moveTo(offsetX - 6, offsetY);
				ctx.lineTo(offsetX + 6, offsetY);
				ctx.stroke();
				ctx.restore();
			}

			let aTL = 0, aMid = 0;
			try {
				const tl = ctx.getImageData(Math.max(0, offsetX), Math.max(0, offsetY), 1, 1).data;
				const mid = ctx.getImageData(paddedW / 2, paddedH / 2, 1, 1).data;
				aTL = tl[3];
				aMid = mid[3];
				log('padded-samples', { TL: Array.from(tl), MID: Array.from(mid), sum: aTL + aMid });
			} catch (err) {
				log('getImageData ERROR', String(err));
			}

			if (DEBUG_ENABLED) {
				const dbg = debugPaddedCanvas;
				dbg.width = paddedW;
				dbg.height = paddedH;
				const dctx = dbg.getContext('2d');
				dctx.clearRect(0, 0, paddedW, paddedH);
				dctx.drawImage(canvas, 0, 0);
				debugMetricsEl.textContent =
`Token: ${token}
Src: ${srcW}×${srcH}
Padded: ${paddedW}×${paddedH}
Grid: ${gridX}×${gridY}
Piece: ${(paddedW / gridX) | 0}×${(paddedH / gridY) | 0}
Samples: TL a=${aTL} MID a=${aMid} sum=${aTL + aMid}
Path: ${frameSource.animated ? 'Animated' : 'Static'}
DrawOK: ${drew ? 'yes' : 'NO (used fallback)'}
`;
			}

			return { canvas, width: paddedW, height: paddedH };
		}

		function rebuildSliceSourceFromCurrentFrame(gridX, gridY) {
			const srcEl = frameSource.sourceElement ? frameSource.sourceElement()
				: frameSource.currentFrameCanvas();
			const srcW = srcEl.width || srcEl.naturalWidth;
			const srcH = srcEl.height || srcEl.naturalHeight;

			const paddedW = Math.ceil(srcW / gridX) * gridX;
			const paddedH = Math.ceil(srcH / gridY) * gridY;

			if (!paddedReuseCanvas) paddedReuseCanvas = document.createElement('canvas');
			if (paddedReuseCanvas.width !== paddedW || paddedReuseCanvas.height !== paddedH) {
				paddedReuseCanvas.width = paddedW;
				paddedReuseCanvas.height = paddedH;
			}

			const ctx = paddedReuseCanvas.getContext('2d', { willReadFrequently: true });
			ctx.clearRect(0, 0, paddedW, paddedH);

			const offsetX = Math.floor((paddedW - srcW) / 2);
			const offsetY = Math.floor((paddedH - srcH) / 2);
			ctx.drawImage(srcEl, offsetX, offsetY, srcW, srcH);

			sliceSourceCanvas = paddedReuseCanvas;
			sliceSourceW = paddedW;
			sliceSourceH = paddedH;
		}

		function attemptDrawTo(ctx, srcDrawable, x, y, w, h, compOp = 'source-over') {
			ctx.save();
			ctx.globalCompositeOperation = compOp;
			ctx.clearRect(x, y, w, h);
			let drew = false;

			try {
				ctx.drawImage(srcDrawable, x, y, w, h);
			} catch (err) {
				log('attemptDrawTo ERROR', { compOp, err: String(err) });
			}

			try {
				const mid = ctx.getImageData((x + (w / 2))|0, (y + (h / 2))|0, 1, 1).data;
				drew = mid[3] > 0;
			} catch (err) {
				log('probe ERROR', String(err));
			}

			ctx.restore();

			log('attemptDrawTo', { compOp, drew });
			return drew;
		}

		/* ================================
		Build / Render
		================================ */
		function createPuzzle() {
			const myToken = ++buildToken;
			log('createPuzzle start', { token: myToken });

			pieceGroups = [];
			puzzleSolved = false;

			const container = puzzleBoard.parentElement;
			const containerWidth = container.clientWidth;
			const containerHeight = container.clientHeight;

			log('container size', { containerWidth, containerHeight });

			if (containerWidth < 10 || containerHeight < 10) {
				log('container too small, reflow defer');
				requestAnimationFrame(() => { if (myToken === buildToken) createPuzzle(); });
				return;
			}

			puzzleBoard.innerHTML = '';

			assemblyArea = document.createElement('div');
			assemblyArea.id = 'assembly-area';
			puzzleBoard.appendChild(assemblyArea);
			puzzleBoard.appendChild(boardPlaceholder);
			puzzleBoard.appendChild(winMessage);

			winMessage.classList.remove('show');
			boardPlaceholder.style.display = 'none';

			const padded = buildPaddedSource(puzzleSizeX, puzzleSizeY, myToken);
			if (myToken !== buildToken) {
				log('stale build after padded; abort', { token: myToken });
				return;
			}

			if (frameSource.animated) {
				// For GIFs, reuse a single canvas we’ll continuously overwrite on each frame tick.
				if (!paddedReuseCanvas) paddedReuseCanvas = document.createElement('canvas');
				paddedReuseCanvas.width = padded.width;
				paddedReuseCanvas.height = padded.height;
				const ctx = paddedReuseCanvas.getContext('2d', { willReadFrequently: true });
				ctx.clearRect(0, 0, padded.width, padded.height);
				// Seed from this build’s padded snapshot (current GIF frame)
				ctx.drawImage(padded.canvas, 0, 0);
				sliceSourceCanvas = paddedReuseCanvas;
				sliceSourceW = paddedReuseCanvas.width;
				sliceSourceH = paddedReuseCanvas.height;
			} else {
				// Static images: just use the padded canvas directly.
				sliceSourceCanvas = padded.canvas;
				sliceSourceW = padded.width;
				sliceSourceH = padded.height;
			}

			const paddedAspect = sliceSourceW / sliceSourceH;

			// Give more space: let assembly take up to 90% of container area
			let assemblyWidth = Math.floor(containerWidth * 0.7);
			let assemblyHeight = Math.round(assemblyWidth / paddedAspect);

			if (assemblyHeight > Math.floor(containerHeight * 0.9)) {
				assemblyHeight = Math.floor(containerHeight * 0.9);
				assemblyWidth = Math.round(assemblyHeight * paddedAspect);
			}

			const boardWidth = containerWidth;
			const boardHeight = containerHeight;

			puzzleBoard.style.width = `${boardWidth}px`;
			puzzleBoard.style.height = `${boardHeight}px`;

			pieceWidth  = Math.max(1, Math.floor(assemblyWidth  / puzzleSizeX));
			pieceHeight = Math.max(1, Math.floor(assemblyHeight / puzzleSizeY));
			assemblyWidth  = pieceWidth  * puzzleSizeX;
			assemblyHeight = pieceHeight * puzzleSizeY;

			const assemblyX = (boardWidth - assemblyWidth) / 2;
			const assemblyY = (boardHeight - assemblyHeight) / 2;

			assemblyArea.style.width = `${assemblyWidth}px`;
			assemblyArea.style.height = `${assemblyHeight}px`;
			assemblyArea.style.left = `${assemblyX}px`;
			assemblyArea.style.top = `${assemblyY}px`;

			log('layout', { assemblyWidth, assemblyHeight, pieceWidth, pieceHeight });

			let sw = sliceSourceW / puzzleSizeX;
			let sh = sliceSourceH / puzzleSizeY;
			log('source-slice', { sw, sh });

			for (let y = 0; y < puzzleSizeY; y++) {
				for (let x = 0; x < puzzleSizeX; x++) {
					if (myToken !== buildToken) {
						log('stale build mid-loop; abort', { token: myToken });
						return;
					}
					const piece = createPieceCanvas(x, y, sw, sh);
					const group = createPieceGroup(piece);
					placeGroupRandomly(
						group,
						boardWidth,
						boardHeight,
						{ x: assemblyX, y: assemblyY, width: assemblyWidth, height: assemblyHeight }
					);
					puzzleBoard.appendChild(group.element);
					pieceGroups.push(group);
				}
			}

			log('createPuzzle done', { token: myToken, pieces: pieceGroups.length });
		}

		function relayoutPuzzlePreserveGroups() {
			if (!assemblyArea || !pieceGroups.length) return;

			// 1) Recompute layout from container just like in createPuzzle()
			const container = puzzleBoard.parentElement;
			const containerWidth = container.clientWidth;
			const containerHeight = container.clientHeight;

			if (containerWidth < 10 || containerHeight < 10) return;

			const paddedAspect = sliceSourceW / sliceSourceH;

			// Board fills container
			const boardWidth = containerWidth;
			const boardHeight = containerHeight;
			puzzleBoard.style.width = `${boardWidth}px`;
			puzzleBoard.style.height = `${boardHeight}px`;

			// Assembly area sizing (same policy as createPuzzle: ~70% width, <=90% height)
			let assemblyWidth = Math.floor(boardWidth * 0.7);
			let assemblyHeight = Math.round(assemblyWidth / paddedAspect);
			if (assemblyHeight > Math.floor(boardHeight * 0.9)) {
				assemblyHeight = Math.floor(boardHeight * 0.9);
				assemblyWidth = Math.round(assemblyHeight * paddedAspect);
			}

			// Recompute piece size from the assembly grid
			pieceWidth = Math.max(1, Math.floor(assemblyWidth / puzzleSizeX));
			pieceHeight = Math.max(1, Math.floor(assemblyHeight / puzzleSizeY));
			assemblyWidth = pieceWidth * puzzleSizeX;
			assemblyHeight = pieceHeight * puzzleSizeY;

			const assemblyX = (boardWidth - assemblyWidth) / 2;
			const assemblyY = (boardHeight - assemblyHeight) / 2;

			// Update assemblyArea rect
			assemblyArea.style.width = `${assemblyWidth}px`;
			assemblyArea.style.height = `${assemblyHeight}px`;
			assemblyArea.style.left = `${assemblyX}px`;
			assemblyArea.style.top = `${assemblyY}px`;

			// 2) Resize every piece canvas and reposition inside its current group
			const sw = sliceSourceW / puzzleSizeX;
			const sh = sliceSourceH / puzzleSizeY;

			for (const group of pieceGroups) {
				// Resize each piece & reposition relative to group's min grid cell
				for (const piece of group.pieces) {
					const gx = parseInt(piece.dataset.correctX, 10);
					const gy = parseInt(piece.dataset.correctY, 10);

					// Resize canvas pixels and CSS size
					piece.width = Math.max(1, pieceWidth);
					piece.height = Math.max(1, pieceHeight);
					piece.style.width = `${pieceWidth}px`;
					piece.style.height = `${pieceHeight}px`;

					// Place inside group based on grid offset from group's min
					const localLeft = (gx - group.minX) * pieceWidth;
					const localTop = (gy - group.minY) * pieceHeight;
					piece.style.left = `${localLeft | 0}px`;
					piece.style.top = `${localTop | 0}px`;
				}
			}

			// 3) Clamp each group to keep it within the new board bounds
			for (const group of pieceGroups) {
				const groupEl = group.element;
				const gW = group.widthInPieces * pieceWidth;
				const gH = group.heightInPieces * pieceHeight;

				const maxX = Math.max(0, puzzleBoard.clientWidth - gW);
				const maxY = Math.max(0, puzzleBoard.clientHeight - gH);

				const curX = parseFloat(groupEl.style.left) || 0;
				const curY = parseFloat(groupEl.style.top) || 0;

				const nx = clamp(curX, 0, maxX) | 0;
				const ny = clamp(curY, 0, maxY) | 0;

				if (nx !== curX) groupEl.style.left = `${nx}px`;
				if (ny !== curY) groupEl.style.top = `${ny}px`;
			}

			// 4) Repaint pieces at their new sizes (important for scaling + GIF sync)
			repaintAllPiecesFromSlice();

			// 5) If the puzzle is already solved, re-center the final group into the new assembly rect
			if (puzzleSolved && pieceGroups.length === 1) {
				const finalGroup = pieceGroups[0];
				finalGroup.element.style.transition = 'left .25s, top .25s';
				const finalX = assemblyX - (finalGroup.minX * pieceWidth);
				const finalY = assemblyY - (finalGroup.minY * pieceHeight);
				finalGroup.element.style.left = `${finalX | 0}px`;
				finalGroup.element.style.top = `${finalY | 0}px`;
			}
		}

		function createPieceCanvas(gridX, gridY, sw, sh) {
			const piece = document.createElement('canvas');
			piece.className = 'puzzle-piece';

			piece.width = Math.max(1, pieceWidth);
			piece.height = Math.max(1, pieceHeight);

			piece.style.width = `${pieceWidth}px`;
			piece.style.height = `${pieceHeight}px`;
			piece.style.left = '0px';
			piece.style.top = '0px';

			piece.dataset.correctX = gridX;
			piece.dataset.correctY = gridY;

			renderPieceFromCurrentFrame(piece, gridX, gridY, sw, sh);

			return piece;
		}

		function renderPieceFromCurrentFrame(piece, gridX, gridY, sw, sh) {
			const ctx = piece.getContext('2d', { willReadFrequently: true });

			ctx.clearRect(0, 0, piece.width, piece.height);

			try {
				ctx.drawImage(
					sliceSourceCanvas,
					gridX * sw, gridY * sh, sw, sh,
					0, 0, piece.width, piece.height
				);
			} catch (err) {
				log('ERROR drawImage piece', { gridX, gridY, err: String(err) });
			}

			if (DEBUG_ENABLED) {
				try {
					const w = Math.min(8, piece.width), h = Math.min(8, piece.height);
					const data = ctx.getImageData(0, 0, w, h).data;
					let aSum = 0; for (let i = 3; i < data.length; i += 4) aSum += data[i];
				} catch (err) {
					log('piece-sample ERROR', String(err));
				}
			}
		}

		function repaintAllPiecesFromSlice() {
			const sw = sliceSourceW / puzzleSizeX;
			const sh = sliceSourceH / puzzleSizeY;
			for (const group of pieceGroups) {
				for (const piece of group.pieces) {
					if (!piece || typeof piece.getContext !== 'function') continue;
					const gx = parseInt(piece.dataset.correctX, 10);
					const gy = parseInt(piece.dataset.correctY, 10);
					renderPieceFromCurrentFrame(piece, gx, gy, sw, sh);
				}
			}
		}

		/* ================================
		Animation loop
		================================ */
		function startAnimationLoop() {
			animRunning = true; // timing is driven by Gifler's onDrawFrame
		}
		function stopAnimationLoop() {
			animRunning = false;
			if (animRAF) cancelAnimationFrame(animRAF);
			animRAF = null;
			try { frameSource?.stop?.(); } catch { }
		}

		/* ================================
		Dragging / Merge (unchanged behavior)
		================================ */
		function createPieceGroup(initialPiece) {
			const groupElement = document.createElement('div');
			groupElement.className = 'puzzle-group';
			groupElement.appendChild(initialPiece);

			const group = {
				element: groupElement,
				pieces: [initialPiece],
				minX: parseInt(initialPiece.dataset.correctX),
				minY: parseInt(initialPiece.dataset.correctY),
				widthInPieces: 1,
				heightInPieces: 1,
			};

			addDragListeners(group);
			return group;
		}

		function placeGroupRandomly(group, boardW, boardH, assemblyRect) {
			const pw = pieceWidth, ph = pieceHeight;
			let x, y;

			const placementArea = Math.floor(Math.random() * 4);
			const safeW = Math.max(0, boardW - pw);
			const safeH = Math.max(0, boardH - ph);

			switch (placementArea) {
				case 0:
					x = Math.random() * safeW;
					y = Math.max(0, Math.random() * Math.max(0, assemblyRect.y - ph));
					break;
				case 1:
					x = Math.random() * safeW;
					y = (assemblyRect.y + assemblyRect.height) +
						Math.random() * Math.max(0, boardH - (assemblyRect.y + assemblyRect.height) - ph);
					break;
				case 2:
					x = Math.max(0, Math.random() * Math.max(0, assemblyRect.x - pw));
					y = Math.random() * safeH;
					break;
				default:
					x = (assemblyRect.x + assemblyRect.width) +
						Math.random() * Math.max(0, boardW - (assemblyRect.x + assemblyRect.width) - pw);
					y = Math.random() * safeH;
					break;
			}

			// Initial placement
			group.element.style.left = `${Math.max(0, x || 0)}px`;
			group.element.style.top  = `${Math.max(0, y || 0)}px`;

			// Push pieces fully back on-screen if any side overflows ---
			// (This handles cases where there is no space on a chosen side.)
			const groupWidth  = group.widthInPieces  * pieceWidth;   // 1 piece initially
			const groupHeight = group.heightInPieces * pieceHeight;
			const maxX = Math.max(0, boardW - groupWidth);
			const maxY = Math.max(0, boardH - groupHeight);

			let nx = parseFloat(group.element.style.left) || 0;
			let ny = parseFloat(group.element.style.top)  || 0;

			nx = Math.min(Math.max(nx, 0), maxX);
			ny = Math.min(Math.max(ny, 0), maxY);

			group.element.style.left = `${nx | 0}px`;
			group.element.style.top  = `${ny | 0}px`;
		}

		function addDragListeners(group) {
			let offsetX, offsetY;
			const groupElement = group.element;

			function onDragStart(e) {
				if (puzzleSolved) return;
				e.preventDefault();

				groupElement.classList.add('dragging');
				puzzleBoard.appendChild(groupElement);

				const t = e.touches?.[0] || e;
				const clientX = t.clientX;
				const clientY = t.clientY;

				const rect = groupElement.getBoundingClientRect();
				offsetX = clientX - rect.left;
				offsetY = clientY - rect.top;

				document.addEventListener('mousemove', onDragMove);
				document.addEventListener('mouseup', onDragEnd);
				document.addEventListener('touchmove', onDragMove, { passive: false });
				document.addEventListener('touchend', onDragEnd);
			}

			function onDragMove(e) {
				e.preventDefault();

				const t = e.touches?.[0] || e;
				const clientX = t.clientX;
				const clientY = t.clientY;

				const boardRect = puzzleBoard.getBoundingClientRect();

				let newX = clientX - boardRect.left - offsetX;
				let newY = clientY - boardRect.top - offsetY;

				const groupWidth = group.widthInPieces * pieceWidth;
				const groupHeight = group.heightInPieces * pieceHeight;

				const maxX = puzzleBoard.clientWidth - groupWidth;
				const maxY = puzzleBoard.clientHeight - groupHeight;

				newX = Math.max(0, Math.min(newX, maxX));
				newY = Math.max(0, Math.min(newY, maxY));

				groupElement.style.left = `${newX | 0}px`;
				groupElement.style.top = `${newY | 0}px`;
			}

			function onDragEnd() {
				groupElement.classList.remove('dragging');

				document.removeEventListener('mousemove', onDragMove);
				document.removeEventListener('mouseup', onDragEnd);
				document.removeEventListener('touchmove', onDragMove);
				document.removeEventListener('touchend', onDragEnd);

				checkForMultiSnap(group);
			}

			groupElement.addEventListener('mousedown', onDragStart);
			groupElement.addEventListener('touchstart', onDragStart, { passive: true });
		}

		function checkForMultiSnap(draggedGroup) {
			let groupToCheck = draggedGroup;
			let madeAMerge = true;
			let mergedAny = false;

			while (madeAMerge) {
				madeAMerge = false;

				for (let i = pieceGroups.length - 1; i >= 0; i--) {
					const stationaryGroup = pieceGroups[i];
					if (stationaryGroup === groupToCheck) continue;

					const snapResult = findAndPerformSnap(groupToCheck, stationaryGroup);
					if (snapResult) {
						groupToCheck = stationaryGroup;
						mergedAny = true;
						madeAMerge = true;
						break;
					}
				}
			}
			// One-time feedback after all chained merges are complete.
			if (mergedAny) {
				playClick();
				runMergeHighlight(groupToCheck);
			}
		}

		function findAndPerformSnap(draggedGroup, stationaryGroup) {
			for (const draggedPiece of draggedGroup.pieces) {
				for (const stationaryPiece of stationaryGroup.pieces) {
					const dir = checkAdjacency(draggedPiece, stationaryPiece);
					if (dir) {
						alignAndMerge(draggedGroup, stationaryGroup, draggedPiece, stationaryPiece, dir);
						return true;
					}
				}
			}
			return false;
		}

		function checkAdjacency(dp, sp) {
			const dpX = parseInt(dp.dataset.correctX);
			const dpY = parseInt(dp.dataset.correctY);
			const spX = parseInt(sp.dataset.correctX);
			const spY = parseInt(sp.dataset.correctY);

			const dr = dp.getBoundingClientRect();
			const sr = sp.getBoundingClientRect();

			if (dpX === spX + 1 && dpY === spY &&
				Math.abs(dr.left - sr.right) < SNAP_TOLERANCE &&
				Math.abs(dr.top - sr.top) < SNAP_TOLERANCE) return 'right';

			if (dpX === spX - 1 && dpY === spY &&
				Math.abs(dr.right - sr.left) < SNAP_TOLERANCE &&
				Math.abs(dr.top - sr.top) < SNAP_TOLERANCE) return 'left';

			if (dpY === spY + 1 && dpX === spX &&
				Math.abs(dr.top - sr.bottom) < SNAP_TOLERANCE &&
				Math.abs(dr.left - sr.left) < SNAP_TOLERANCE) return 'down';

			if (dpY === spY - 1 && dpX === spX &&
				Math.abs(dr.bottom - sr.top) < SNAP_TOLERANCE &&
				Math.abs(dr.left - sr.left) < SNAP_TOLERANCE) return 'up';

			return null;
		}

		function alignAndMerge(dg, sg, dp, sp, direction) {
			const sgPos = { left: sg.element.offsetLeft, top: sg.element.offsetTop };
			const spOff = { left: parseFloat(sp.style.left), top: parseFloat(sp.style.top) };
			const dpOff = { left: parseFloat(dp.style.left), top: parseFloat(dp.style.top) };

			let targetLeft, targetTop;

			switch (direction) {
				case 'right':
					targetLeft = sgPos.left + spOff.left + pieceWidth - dpOff.left;
					targetTop = sgPos.top + spOff.top - dpOff.top;
					break;
				case 'left':
					targetLeft = sgPos.left + spOff.left - pieceWidth - dpOff.left;
					targetTop = sgPos.top + spOff.top - dpOff.top;
					break;
				case 'down':
					targetLeft = sgPos.left + spOff.left - dpOff.left;
					targetTop = sgPos.top + spOff.top + pieceHeight - dpOff.top;
					break;
				case 'up':
					targetLeft = sgPos.left + spOff.left - dpOff.left;
					targetTop = sgPos.top + spOff.top - pieceHeight - dpOff.top;
					break;
			}

			dg.element.style.left = `${targetLeft | 0}px`;
			dg.element.style.top = `${targetTop | 0}px`;

			mergeGroups(dg, sg);
		}

		function mergeGroups(dg, sg) {
			const dEl = dg.element;
			const sEl = sg.element;

			const offsetX = dEl.offsetLeft - sEl.offsetLeft;
			const offsetY = dEl.offsetTop - sEl.offsetTop;

			while (dEl.firstChild) {
				const node = dEl.firstChild;
				// If this is a transient visual overlay, just drop it.
				if (node.nodeType === 1 && node.classList && node.classList.contains('merge-highlight')) {
					node.remove();
					continue;
				}
				// Move node into sg
				if (node.style) {
					node.style.left = `${(parseFloat(node.style.left || '0') + offsetX) | 0}px`;
					node.style.top = `${(parseFloat(node.style.top || '0') + offsetY) | 0}px`;
				}
				sEl.appendChild(node);
				// Only canvases are puzzle pieces
				if (node.tagName === 'CANVAS') {
					sg.pieces.push(node);
				}
			}

			let minX = Infinity, minY = Infinity;
			for (const p of sg.pieces) {
				const l = parseFloat(p.style.left);
				const t = parseFloat(p.style.top);
				if (l < minX) minX = l;
				if (t < minY) minY = t;
			}

			if (minX || minY) {
				sEl.style.left = `${(sEl.offsetLeft + minX) | 0}px`;
				sEl.style.top = `${(sEl.offsetTop + minY) | 0}px`;

				for (const p of sg.pieces) {
					p.style.left = `${(parseFloat(p.style.left) - minX) | 0}px`;
					p.style.top = `${(parseFloat(p.style.top) - minY) | 0}px`;
				}
			}

			puzzleBoard.removeChild(dEl);
			pieceGroups = pieceGroups.filter(g => g !== dg);

			sg.minX = Math.min(sg.minX, dg.minX);
			sg.minY = Math.min(sg.minY, dg.minY);

			let maxX = sg.minX, maxY = sg.minY;
			for (const p of sg.pieces) {
				const px = parseInt(p.dataset.correctX);
				const py = parseInt(p.dataset.correctY);
				if (px > maxX) maxX = px;
				if (py > maxY) maxY = py;
			}

			sg.widthInPieces = maxX - sg.minX + 1;
			sg.heightInPieces = maxY - sg.minY + 1;

			checkWinCondition();
		}

		function checkWinCondition() {
			if (pieceGroups.length === 1 &&
				pieceGroups[0].pieces.length === puzzleSizeX * puzzleSizeY) {

				const finalGroup = pieceGroups[0];

				const finalX = assemblyArea.offsetLeft - (finalGroup.minX * pieceWidth);
				const finalY = assemblyArea.offsetTop - (finalGroup.minY * pieceHeight);

				finalGroup.element.style.transition = 'left .5s, top .5s, filter .5s';
				finalGroup.element.style.left = `${finalX}px`;
				finalGroup.element.style.top = `${finalY}px`;
				finalGroup.element.style.cursor = 'default';
				finalGroup.element.style.zIndex = '5';
				finalGroup.element.style.filter = 'none';

				puzzleSolved = true;
				winMessage.classList.add('show');
			}
		}
	</script>
</body>
</html>